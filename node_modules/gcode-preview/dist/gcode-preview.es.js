import{Ray as t,Plane as e,MathUtils as n,EventDispatcher as i,Vector3 as s,MOUSE as o,TOUCH as r,Quaternion as a,Spherical as l,Vector2 as d,UniformsLib as c,ShaderLib as h,UniformsUtils as u,ShaderMaterial as p,Box3 as m,InstancedBufferGeometry as f,Float32BufferAttribute as g,InstancedInterleavedBuffer as v,InterleavedBufferAttribute as y,WireframeGeometry as b,Sphere as w,Vector4 as x,Matrix4 as S,Line3 as E,Mesh as L,LineSegments as C,Color as O,BufferGeometry as M,LineBasicMaterial as A,LineDashedMaterial as T,Scene as z,REVISION as _,WebGLRenderer as j,PerspectiveCamera as P,Fog as I,AxesHelper as D,AmbientLight as R,PointLight as F,Group as N,Euler as H,MeshLambertMaterial as U,BatchedMesh as k}from"three";import{GUI as B}from"lil-gui";function V(t,e,n,i){return new(n||(n=Promise))((function(s,o){function r(t){try{l(i.next(t))}catch(t){o(t)}}function a(t){try{l(i.throw(t))}catch(t){o(t)}}function l(t){var e;t.done?s(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(r,a)}l((i=i.apply(t,e||[])).next())}))}"function"==typeof SuppressedError&&SuppressedError;class G{constructor(t,e,n,i){this.size=t,this.width=e,this.height=n,this.charLength=i,this.chars=""}static parse(t){const e=t.split(" "),n=e[0],i=n.split("x");return new G(n,+i[0],+i[1],+e[1])}get src(){return"data:image/jpeg;base64,"+this.chars}get isValid(){return this.chars.length==this.charLength&&/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(this.chars)}}class W{constructor(t,e,n,i){this.src=t,this.gcode=e,this.params=n,this.comment=i}}class Y extends W{constructor(t,e,n,i){super(t,e,n,i),this.params=n}}class Z extends W{constructor(t,e,n,i){super(t,e,void 0,n),this.toolIndex=i}}class K{constructor(t,e,n,i=0){this.layer=t,this.commands=e,this.lineNumber=n,this.height=i}}class X{constructor(t){this.lines=[],this.preamble=new K(-1,[],0),this.layers=[],this.curZ=0,this.maxZ=0,this.metadata={thumbnails:{}},this.tolerance=0,this.tolerance=null!=t?t:this.tolerance}parseGCode(t){const e=Array.isArray(t)?t:t.split("\n");this.lines=this.lines.concat(e);const n=this.lines2commands(e);this.groupIntoLayers(n);const i=this.parseMetadata(n.filter((t=>t.comment))).thumbnails;for(const[t,e]of Object.entries(i))this.metadata.thumbnails[t]=e;return{layers:this.layers,metadata:this.metadata}}lines2commands(t){return t.map((t=>this.parseCommand(t)))}parseCommand(t,e=!0){var n;const i=t.trim().split(";"),s=i[0],o=e&&i[1]||void 0,r=s.split(/([a-zA-Z])/g).slice(1).map((t=>t.trim())),a=r.length?`${null===(n=r[0])||void 0===n?void 0:n.toLowerCase()}${r[1]}`:"",l=this.parseParams(r.slice(2));switch(a){case"g0":case"g00":case"g1":case"g01":case"g2":case"g02":case"g3":case"g03":return new Y(t,a,l,o);case"t0":return new Z(t,a,o,0);case"t1":return new Z(t,a,o,1);case"t2":return new Z(t,a,o,2);case"t3":return new Z(t,a,o,3);case"t4":return new Z(t,a,o,4);case"t5":return new Z(t,a,o,5);case"t6":return new Z(t,a,o,6);case"t7":return new Z(t,a,o,7);default:return new W(t,a,l,o)}}parseMove(t){return t.reduce(((t,e)=>{const n=e.charAt(0).toLowerCase();return"x"!=n&&"y"!=n&&"z"!=n&&"e"!=n&&"r"!=n&&"f"!=n&&"i"!=n&&"j"!=n||(t[n]=parseFloat(e.slice(1))),t}),{})}isAlpha(t){const e=t.charCodeAt(0);return e>=97&&e<=122||e>=65&&e<=90}parseParams(t){return t.reduce(((t,e,n,i)=>{if(n%2==0)return t;let s=i[n-1];return s=s.toLowerCase(),this.isAlpha(s)&&(t[s]=parseFloat(e)),t}),{})}groupIntoLayers(t){var e;for(let n=0;n<t.length;n++){const i=t[n];if(i instanceof Y){const t=i.params;if(t.z&&(this.curZ=t.z),(null!==(e=t.e)&&void 0!==e?e:0)>0&&(null!=t.x||null!=t.y)&&Math.abs(this.curZ-(this.maxZ||-1/0))>this.tolerance){const t=Math.abs(this.curZ-this.maxZ);this.maxZ=this.curZ,this.layers.push(new K(this.layers.length,[],n,t))}}this.maxLayer.commands.push(i)}return this.layers}get maxLayer(){var t;return null!==(t=this.layers[this.layers.length-1])&&void 0!==t?t:this.preamble}parseMetadata(t){const e={};let n;for(const i of t){const t=i.comment;if(!t)continue;const s=t.indexOf("thumbnail begin"),o=t.indexOf("thumbnail end");s>-1?n=G.parse(t.slice(s+15).trim()):n&&(-1==o?n.chars+=t.trim():(n.isValid&&(e[n.size]=n),n=void 0))}return{thumbnails:e}}}X.prototype.parseGcode=X.prototype.parseGCode;const q={type:"change"},J={type:"start"},$={type:"end"},Q=new t,tt=new e,et=Math.cos(70*n.DEG2RAD);class nt extends i{constructor(t,e){super(),this.object=t,this.domElement=e,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new s,this.cursor=new s,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minTargetRadius=0,this.maxTargetRadius=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:o.ROTATE,MIDDLE:o.DOLLY,RIGHT:o.PAN},this.touches={ONE:r.ROTATE,TWO:r.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return u.phi},this.getAzimuthalAngle=function(){return u.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(t){t.addEventListener("keydown",st),this._domElementKeyEvents=t},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",st),this._domElementKeyEvents=null},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(q),n.update(),c=i.NONE},this.update=function(){const e=new s,o=(new a).setFromUnitVectors(t.up,new s(0,1,0)),r=o.clone().invert(),l=new s,d=new a,g=new s,v=2*Math.PI;return function(a=null){const y=n.object.position;e.copy(y).sub(n.target),e.applyQuaternion(o),u.setFromVector3(e),n.autoRotate&&c===i.NONE&&_(function(t){return null!==t?2*Math.PI/60*n.autoRotateSpeed*t:2*Math.PI/60/60*n.autoRotateSpeed}(a)),n.enableDamping?(u.theta+=p.theta*n.dampingFactor,u.phi+=p.phi*n.dampingFactor):(u.theta+=p.theta,u.phi+=p.phi);let b=n.minAzimuthAngle,w=n.maxAzimuthAngle;isFinite(b)&&isFinite(w)&&(b<-Math.PI?b+=v:b>Math.PI&&(b-=v),w<-Math.PI?w+=v:w>Math.PI&&(w-=v),u.theta=b<=w?Math.max(b,Math.min(w,u.theta)):u.theta>(b+w)/2?Math.max(b,u.theta):Math.min(w,u.theta)),u.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,u.phi)),u.makeSafe(),!0===n.enableDamping?n.target.addScaledVector(f,n.dampingFactor):n.target.add(f),n.target.sub(n.cursor),n.target.clampLength(n.minTargetRadius,n.maxTargetRadius),n.target.add(n.cursor),n.zoomToCursor&&M||n.object.isOrthographicCamera?u.radius=H(u.radius):u.radius=H(u.radius*m),e.setFromSpherical(u),e.applyQuaternion(r),y.copy(n.target).add(e),n.object.lookAt(n.target),!0===n.enableDamping?(p.theta*=1-n.dampingFactor,p.phi*=1-n.dampingFactor,f.multiplyScalar(1-n.dampingFactor)):(p.set(0,0,0),f.set(0,0,0));let x=!1;if(n.zoomToCursor&&M){let i=null;if(n.object.isPerspectiveCamera){const t=e.length();i=H(t*m);const s=t-i;n.object.position.addScaledVector(C,s),n.object.updateMatrixWorld()}else if(n.object.isOrthographicCamera){const t=new s(O.x,O.y,0);t.unproject(n.object),n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/m)),n.object.updateProjectionMatrix(),x=!0;const o=new s(O.x,O.y,0);o.unproject(n.object),n.object.position.sub(o).add(t),n.object.updateMatrixWorld(),i=e.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),n.zoomToCursor=!1;null!==i&&(this.screenSpacePanning?n.target.set(0,0,-1).transformDirection(n.object.matrix).multiplyScalar(i).add(n.object.position):(Q.origin.copy(n.object.position),Q.direction.set(0,0,-1).transformDirection(n.object.matrix),Math.abs(n.object.up.dot(Q.direction))<et?t.lookAt(n.target):(tt.setFromNormalAndCoplanarPoint(n.object.up,n.target),Q.intersectPlane(tt,n.target))))}else n.object.isOrthographicCamera&&(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/m)),n.object.updateProjectionMatrix(),x=!0);return m=1,M=!1,!!(x||l.distanceToSquared(n.object.position)>h||8*(1-d.dot(n.object.quaternion))>h||g.distanceToSquared(n.target)>0)&&(n.dispatchEvent(q),l.copy(n.object.position),d.copy(n.object.quaternion),g.copy(n.target),!0)}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",ot),n.domElement.removeEventListener("pointerdown",K),n.domElement.removeEventListener("pointercancel",nt),n.domElement.removeEventListener("wheel",it),n.domElement.removeEventListener("pointermove",X),n.domElement.removeEventListener("pointerup",nt),null!==n._domElementKeyEvents&&(n._domElementKeyEvents.removeEventListener("keydown",st),n._domElementKeyEvents=null)};const n=this,i={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let c=i.NONE;const h=1e-6,u=new l,p=new l;let m=1;const f=new s,g=new d,v=new d,y=new d,b=new d,w=new d,x=new d,S=new d,E=new d,L=new d,C=new s,O=new d;let M=!1;const A=[],T={};function z(){return Math.pow(.95,n.zoomSpeed)}function _(t){p.theta-=t}function j(t){p.phi-=t}const P=function(){const t=new s;return function(e,n){t.setFromMatrixColumn(n,0),t.multiplyScalar(-e),f.add(t)}}(),I=function(){const t=new s;return function(e,i){!0===n.screenSpacePanning?t.setFromMatrixColumn(i,1):(t.setFromMatrixColumn(i,0),t.crossVectors(n.object.up,t)),t.multiplyScalar(e),f.add(t)}}(),D=function(){const t=new s;return function(e,i){const s=n.domElement;if(n.object.isPerspectiveCamera){const o=n.object.position;t.copy(o).sub(n.target);let r=t.length();r*=Math.tan(n.object.fov/2*Math.PI/180),P(2*e*r/s.clientHeight,n.object.matrix),I(2*i*r/s.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(P(e*(n.object.right-n.object.left)/n.object.zoom/s.clientWidth,n.object.matrix),I(i*(n.object.top-n.object.bottom)/n.object.zoom/s.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function R(t){n.object.isPerspectiveCamera||n.object.isOrthographicCamera?m/=t:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function F(t){n.object.isPerspectiveCamera||n.object.isOrthographicCamera?m*=t:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function N(t){if(!n.zoomToCursor)return;M=!0;const e=n.domElement.getBoundingClientRect(),i=t.clientX-e.left,s=t.clientY-e.top,o=e.width,r=e.height;O.x=i/o*2-1,O.y=-s/r*2+1,C.set(O.x,O.y,1).unproject(n.object).sub(n.object.position).normalize()}function H(t){return Math.max(n.minDistance,Math.min(n.maxDistance,t))}function U(t){g.set(t.clientX,t.clientY)}function k(t){b.set(t.clientX,t.clientY)}function B(){if(1===A.length)g.set(A[0].pageX,A[0].pageY);else{const t=.5*(A[0].pageX+A[1].pageX),e=.5*(A[0].pageY+A[1].pageY);g.set(t,e)}}function V(){if(1===A.length)b.set(A[0].pageX,A[0].pageY);else{const t=.5*(A[0].pageX+A[1].pageX),e=.5*(A[0].pageY+A[1].pageY);b.set(t,e)}}function G(){const t=A[0].pageX-A[1].pageX,e=A[0].pageY-A[1].pageY,n=Math.sqrt(t*t+e*e);S.set(0,n)}function W(t){if(1==A.length)v.set(t.pageX,t.pageY);else{const e=at(t),n=.5*(t.pageX+e.x),i=.5*(t.pageY+e.y);v.set(n,i)}y.subVectors(v,g).multiplyScalar(n.rotateSpeed);const e=n.domElement;_(2*Math.PI*y.x/e.clientHeight),j(2*Math.PI*y.y/e.clientHeight),g.copy(v)}function Y(t){if(1===A.length)w.set(t.pageX,t.pageY);else{const e=at(t),n=.5*(t.pageX+e.x),i=.5*(t.pageY+e.y);w.set(n,i)}x.subVectors(w,b).multiplyScalar(n.panSpeed),D(x.x,x.y),b.copy(w)}function Z(t){const e=at(t),i=t.pageX-e.x,s=t.pageY-e.y,o=Math.sqrt(i*i+s*s);E.set(0,o),L.set(0,Math.pow(E.y/S.y,n.zoomSpeed)),R(L.y),S.copy(E)}function K(t){!1!==n.enabled&&(0===A.length&&(n.domElement.setPointerCapture(t.pointerId),n.domElement.addEventListener("pointermove",X),n.domElement.addEventListener("pointerup",nt)),function(t){A.push(t)}(t),"touch"===t.pointerType?function(t){switch(rt(t),A.length){case 1:switch(n.touches.ONE){case r.ROTATE:if(!1===n.enableRotate)return;B(),c=i.TOUCH_ROTATE;break;case r.PAN:if(!1===n.enablePan)return;V(),c=i.TOUCH_PAN;break;default:c=i.NONE}break;case 2:switch(n.touches.TWO){case r.DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;n.enableZoom&&G(),n.enablePan&&V(),c=i.TOUCH_DOLLY_PAN;break;case r.DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;n.enableZoom&&G(),n.enableRotate&&B(),c=i.TOUCH_DOLLY_ROTATE;break;default:c=i.NONE}break;default:c=i.NONE}c!==i.NONE&&n.dispatchEvent(J)}(t):function(t){let e;switch(t.button){case 0:e=n.mouseButtons.LEFT;break;case 1:e=n.mouseButtons.MIDDLE;break;case 2:e=n.mouseButtons.RIGHT;break;default:e=-1}switch(e){case o.DOLLY:if(!1===n.enableZoom)return;!function(t){N(t),S.set(t.clientX,t.clientY)}(t),c=i.DOLLY;break;case o.ROTATE:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===n.enablePan)return;k(t),c=i.PAN}else{if(!1===n.enableRotate)return;U(t),c=i.ROTATE}break;case o.PAN:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===n.enableRotate)return;U(t),c=i.ROTATE}else{if(!1===n.enablePan)return;k(t),c=i.PAN}break;default:c=i.NONE}c!==i.NONE&&n.dispatchEvent(J)}(t))}function X(t){!1!==n.enabled&&("touch"===t.pointerType?function(t){switch(rt(t),c){case i.TOUCH_ROTATE:if(!1===n.enableRotate)return;W(t),n.update();break;case i.TOUCH_PAN:if(!1===n.enablePan)return;Y(t),n.update();break;case i.TOUCH_DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;!function(t){n.enableZoom&&Z(t),n.enablePan&&Y(t)}(t),n.update();break;case i.TOUCH_DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;!function(t){n.enableZoom&&Z(t),n.enableRotate&&W(t)}(t),n.update();break;default:c=i.NONE}}(t):function(t){switch(c){case i.ROTATE:if(!1===n.enableRotate)return;!function(t){v.set(t.clientX,t.clientY),y.subVectors(v,g).multiplyScalar(n.rotateSpeed);const e=n.domElement;_(2*Math.PI*y.x/e.clientHeight),j(2*Math.PI*y.y/e.clientHeight),g.copy(v),n.update()}(t);break;case i.DOLLY:if(!1===n.enableZoom)return;!function(t){E.set(t.clientX,t.clientY),L.subVectors(E,S),L.y>0?R(z()):L.y<0&&F(z()),S.copy(E),n.update()}(t);break;case i.PAN:if(!1===n.enablePan)return;!function(t){w.set(t.clientX,t.clientY),x.subVectors(w,b).multiplyScalar(n.panSpeed),D(x.x,x.y),b.copy(w),n.update()}(t)}}(t))}function nt(t){!function(t){delete T[t.pointerId];for(let e=0;e<A.length;e++)if(A[e].pointerId==t.pointerId)return void A.splice(e,1)}(t),0===A.length&&(n.domElement.releasePointerCapture(t.pointerId),n.domElement.removeEventListener("pointermove",X),n.domElement.removeEventListener("pointerup",nt)),n.dispatchEvent($),c=i.NONE}function it(t){!1!==n.enabled&&!1!==n.enableZoom&&c===i.NONE&&(t.preventDefault(),n.dispatchEvent(J),function(t){N(t),t.deltaY<0?F(z()):t.deltaY>0&&R(z()),n.update()}(t),n.dispatchEvent($))}function st(t){!1!==n.enabled&&!1!==n.enablePan&&function(t){let e=!1;switch(t.code){case n.keys.UP:t.ctrlKey||t.metaKey||t.shiftKey?j(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):D(0,n.keyPanSpeed),e=!0;break;case n.keys.BOTTOM:t.ctrlKey||t.metaKey||t.shiftKey?j(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):D(0,-n.keyPanSpeed),e=!0;break;case n.keys.LEFT:t.ctrlKey||t.metaKey||t.shiftKey?_(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):D(n.keyPanSpeed,0),e=!0;break;case n.keys.RIGHT:t.ctrlKey||t.metaKey||t.shiftKey?_(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):D(-n.keyPanSpeed,0),e=!0}e&&(t.preventDefault(),n.update())}(t)}function ot(t){!1!==n.enabled&&t.preventDefault()}function rt(t){let e=T[t.pointerId];void 0===e&&(e=new d,T[t.pointerId]=e),e.set(t.pageX,t.pageY)}function at(t){const e=t.pointerId===A[0].pointerId?A[1]:A[0];return T[e.pointerId]}n.domElement.addEventListener("contextmenu",ot),n.domElement.addEventListener("pointerdown",K),n.domElement.addEventListener("pointercancel",nt),n.domElement.addEventListener("wheel",it,{passive:!1}),this.update()}}c.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new d(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}},h.line={uniforms:u.merge([c.common,c.fog,c.line]),vertexShader:"\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",fragmentShader:"\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t"};class it extends p{constructor(t){super({type:"LineMaterial",uniforms:u.clone(h.line.uniforms),vertexShader:h.line.vertexShader,fragmentShader:h.line.fragmentShader,clipping:!0}),this.isLineMaterial=!0,this.setValues(t)}get color(){return this.uniforms.diffuse.value}set color(t){this.uniforms.diffuse.value=t}get worldUnits(){return"WORLD_UNITS"in this.defines}set worldUnits(t){!0===t?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}get linewidth(){return this.uniforms.linewidth.value}set linewidth(t){this.uniforms.linewidth&&(this.uniforms.linewidth.value=t)}get dashed(){return"USE_DASH"in this.defines}set dashed(t){!0===t!==this.dashed&&(this.needsUpdate=!0),!0===t?this.defines.USE_DASH="":delete this.defines.USE_DASH}get dashScale(){return this.uniforms.dashScale.value}set dashScale(t){this.uniforms.dashScale.value=t}get dashSize(){return this.uniforms.dashSize.value}set dashSize(t){this.uniforms.dashSize.value=t}get dashOffset(){return this.uniforms.dashOffset.value}set dashOffset(t){this.uniforms.dashOffset.value=t}get gapSize(){return this.uniforms.gapSize.value}set gapSize(t){this.uniforms.gapSize.value=t}get opacity(){return this.uniforms.opacity.value}set opacity(t){this.uniforms&&(this.uniforms.opacity.value=t)}get resolution(){return this.uniforms.resolution.value}set resolution(t){this.uniforms.resolution.value.copy(t)}get alphaToCoverage(){return"USE_ALPHA_TO_COVERAGE"in this.defines}set alphaToCoverage(t){this.defines&&(!0===t!==this.alphaToCoverage&&(this.needsUpdate=!0),!0===t?(this.defines.USE_ALPHA_TO_COVERAGE="",this.extensions.derivatives=!0):(delete this.defines.USE_ALPHA_TO_COVERAGE,this.extensions.derivatives=!1))}}const st=new m,ot=new s;class rt extends f{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.setAttribute("position",new g([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.setAttribute("uv",new g([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))}applyMatrix4(t){const e=this.attributes.instanceStart,n=this.attributes.instanceEnd;return void 0!==e&&(e.applyMatrix4(t),n.applyMatrix4(t),e.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}setPositions(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const n=new v(e,6,1);return this.setAttribute("instanceStart",new y(n,3,0)),this.setAttribute("instanceEnd",new y(n,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(t){let e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));const n=new v(e,6,1);return this.setAttribute("instanceColorStart",new y(n,3,0)),this.setAttribute("instanceColorEnd",new y(n,3,3)),this}fromWireframeGeometry(t){return this.setPositions(t.attributes.position.array),this}fromEdgesGeometry(t){return this.setPositions(t.attributes.position.array),this}fromMesh(t){return this.fromWireframeGeometry(new b(t.geometry)),this}fromLineSegments(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new m);const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;void 0!==t&&void 0!==e&&(this.boundingBox.setFromBufferAttribute(t),st.setFromBufferAttribute(e),this.boundingBox.union(st))}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new w),null===this.boundingBox&&this.computeBoundingBox();const t=this.attributes.instanceStart,e=this.attributes.instanceEnd;if(void 0!==t&&void 0!==e){const n=this.boundingSphere.center;this.boundingBox.getCenter(n);let i=0;for(let s=0,o=t.count;s<o;s++)ot.fromBufferAttribute(t,s),i=Math.max(i,n.distanceToSquared(ot)),ot.fromBufferAttribute(e,s),i=Math.max(i,n.distanceToSquared(ot));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(t){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(t)}}const at=new s,lt=new s,dt=new x,ct=new x,ht=new x,ut=new s,pt=new S,mt=new E,ft=new s,gt=new m,vt=new w,yt=new x;let bt,wt;function xt(t,e,n){return yt.set(0,0,-e,1).applyMatrix4(t.projectionMatrix),yt.multiplyScalar(1/yt.w),yt.x=wt/n.width,yt.y=wt/n.height,yt.applyMatrix4(t.projectionMatrixInverse),yt.multiplyScalar(1/yt.w),Math.abs(Math.max(yt.x,yt.y))}class St extends L{constructor(t=new rt,e=new it({color:16777215*Math.random()})){super(t,e),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const t=this.geometry,e=t.attributes.instanceStart,n=t.attributes.instanceEnd,i=new Float32Array(2*e.count);for(let t=0,s=0,o=e.count;t<o;t++,s+=2)at.fromBufferAttribute(e,t),lt.fromBufferAttribute(n,t),i[s]=0===s?0:i[s-1],i[s+1]=i[s]+at.distanceTo(lt);const s=new v(i,2,1);return t.setAttribute("instanceDistanceStart",new y(s,1,0)),t.setAttribute("instanceDistanceEnd",new y(s,1,1)),this}raycast(t,e){const i=this.material.worldUnits,o=t.camera;null!==o||i||console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const r=void 0!==t.params.Line2&&t.params.Line2.threshold||0;bt=t.ray;const a=this.matrixWorld,l=this.geometry,d=this.material;let c,h;if(wt=d.linewidth+r,null===l.boundingSphere&&l.computeBoundingSphere(),vt.copy(l.boundingSphere).applyMatrix4(a),i)c=.5*wt;else{c=xt(o,Math.max(o.near,vt.distanceToPoint(bt.origin)),d.resolution)}if(vt.radius+=c,!1!==bt.intersectsSphere(vt)){if(null===l.boundingBox&&l.computeBoundingBox(),gt.copy(l.boundingBox).applyMatrix4(a),i)h=.5*wt;else{h=xt(o,Math.max(o.near,gt.distanceToPoint(bt.origin)),d.resolution)}gt.expandByScalar(h),!1!==bt.intersectsBox(gt)&&(i?function(t,e){const n=t.matrixWorld,i=t.geometry,o=i.attributes.instanceStart,r=i.attributes.instanceEnd;for(let a=0,l=Math.min(i.instanceCount,o.count);a<l;a++){mt.start.fromBufferAttribute(o,a),mt.end.fromBufferAttribute(r,a),mt.applyMatrix4(n);const i=new s,l=new s;bt.distanceSqToSegment(mt.start,mt.end,l,i),l.distanceTo(i)<.5*wt&&e.push({point:l,pointOnLine:i,distance:bt.origin.distanceTo(l),object:t,face:null,faceIndex:a,uv:null,uv1:null})}}(this,e):function(t,e,i){const o=e.projectionMatrix,r=t.material.resolution,a=t.matrixWorld,l=t.geometry,d=l.attributes.instanceStart,c=l.attributes.instanceEnd,h=Math.min(l.instanceCount,d.count),u=-e.near;bt.at(1,ht),ht.w=1,ht.applyMatrix4(e.matrixWorldInverse),ht.applyMatrix4(o),ht.multiplyScalar(1/ht.w),ht.x*=r.x/2,ht.y*=r.y/2,ht.z=0,ut.copy(ht),pt.multiplyMatrices(e.matrixWorldInverse,a);for(let e=0,l=h;e<l;e++){if(dt.fromBufferAttribute(d,e),ct.fromBufferAttribute(c,e),dt.w=1,ct.w=1,dt.applyMatrix4(pt),ct.applyMatrix4(pt),dt.z>u&&ct.z>u)continue;if(dt.z>u){const t=dt.z-ct.z,e=(dt.z-u)/t;dt.lerp(ct,e)}else if(ct.z>u){const t=ct.z-dt.z,e=(ct.z-u)/t;ct.lerp(dt,e)}dt.applyMatrix4(o),ct.applyMatrix4(o),dt.multiplyScalar(1/dt.w),ct.multiplyScalar(1/ct.w),dt.x*=r.x/2,dt.y*=r.y/2,ct.x*=r.x/2,ct.y*=r.y/2,mt.start.copy(dt),mt.start.z=0,mt.end.copy(ct),mt.end.z=0;const l=mt.closestPointToPointParameter(ut,!0);mt.at(l,ft);const h=n.lerp(dt.z,ct.z,l),p=h>=-1&&h<=1,m=ut.distanceTo(ft)<.5*wt;if(p&&m){mt.start.fromBufferAttribute(d,e),mt.end.fromBufferAttribute(c,e),mt.start.applyMatrix4(a),mt.end.applyMatrix4(a);const n=new s,o=new s;bt.distanceSqToSegment(mt.start,mt.end,o,n),i.push({point:o,pointOnLine:n,distance:bt.origin.distanceTo(o),object:t,face:null,faceIndex:e,uv:null,uv1:null})}}}(this,o,e))}}}class Et extends C{constructor(t,e,n,i,s=4473924,o=8947848){s=new O(s),o=new O(o);const r=Math.round(t/e);n=Math.round(n/i)*i/2;const a=[],l=[];let d=0;for(let i=-1*(t=r*e/2);i<=t;i+=e){a.push(i,0,-1*n,i,0,n);const t=0===i?s:o;t.toArray(l,d),d+=3,t.toArray(l,d),d+=3,t.toArray(l,d),d+=3,t.toArray(l,d),d+=3}for(let e=-1*n;e<=n;e+=i){a.push(-1*t,0,e,t,0,e);const n=0===e?s:o;n.toArray(l,d),d+=3,n.toArray(l,d),d+=3,n.toArray(l,d),d+=3,n.toArray(l,d),d+=3}const c=new M;c.setAttribute("position",new g(a,3)),c.setAttribute("color",new g(l,3));super(c,new A({vertexColors:!0,toneMapped:!1}))}}function Lt(t,e,n,i){const s=function(t,e,n){t*=.5,e*=.5,n*=.5;const i=new M,s=[];return s.push(-t,-e,-n,-t,e,-n,-t,e,-n,t,e,-n,t,e,-n,t,-e,-n,t,-e,-n,-t,-e,-n,-t,-e,n,-t,e,n,-t,e,n,t,e,n,t,e,n,t,-e,n,t,-e,n,-t,-e,n,-t,-e,-n,-t,-e,n,-t,e,-n,-t,e,n,t,e,-n,t,e,n,t,-e,-n,t,-e,n),i.setAttribute("position",new g(s,3)),i}(t,e,n),o=new C(s,new T({color:new O(i),dashSize:3,gapSize:1}));return o.computeLineDistances(),o}var Ct=function(){var t=0,e=document.createElement("div");function n(t){return e.appendChild(t.dom),t}function i(n){for(var i=0;i<e.children.length;i++)e.children[i].style.display=i===n?"block":"none";t=n}e.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",e.addEventListener("click",(function(n){n.preventDefault(),i(++t%e.children.length)}),!1);var s=(performance||Date).now(),o=s,r=0,a=n(new Ct.Panel("FPS","#0ff","#002")),l=n(new Ct.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var d=n(new Ct.Panel("MB","#f08","#201"));return i(0),{REVISION:16,dom:e,addPanel:n,showPanel:i,begin:function(){s=(performance||Date).now()},end:function(){r++;var t=(performance||Date).now();if(l.update(t-s,200),t>=o+1e3&&(a.update(1e3*r/(t-o),100),o=t,r=0,d)){var e=performance.memory;d.update(e.usedJSHeapSize/1048576,e.jsHeapSizeLimit/1048576)}return t},update:function(){s=this.end()},domElement:e,setMode:i}};Ct.Panel=function(t,e,n){var i=1/0,s=0,o=Math.round,r=o(window.devicePixelRatio||1),a=80*r,l=48*r,d=3*r,c=2*r,h=3*r,u=15*r,p=74*r,m=30*r,f=document.createElement("canvas");f.width=a,f.height=l,f.style.cssText="width:80px;height:48px";var g=f.getContext("2d");return g.font="bold "+9*r+"px Helvetica,Arial,sans-serif",g.textBaseline="top",g.fillStyle=n,g.fillRect(0,0,a,l),g.fillStyle=e,g.fillText(t,d,c),g.fillRect(h,u,p,m),g.fillStyle=n,g.globalAlpha=.9,g.fillRect(h,u,p,m),{dom:f,update:function(l,v){i=Math.min(i,l),s=Math.max(s,l),g.fillStyle=n,g.globalAlpha=1,g.fillRect(0,0,a,u),g.fillStyle=e,g.fillText(o(l)+" "+t+" ("+o(i)+"-"+o(s)+")",d,c),g.drawImage(f,h+r,u,p-r,m,h,u,p-r,m),g.fillRect(h+p-r,u,r,m),g.fillStyle=n,g.globalAlpha=.9,g.fillRect(h+p-r,u,r,o((1-l/v)*m))}}};var Ot=Ct;class Mt{constructor(t,e){this.openFolders=[],this.watchedObject=t,this.options=e,this.gui=new B,this.gui.title("Dev info"),this.setup()}setup(){this.loadOpenFolders(),this.options&&!this.options.renderer||this.setupRedererFolder(),this.options&&!this.options.camera||this.setupCameraFolder(),this.options&&!this.options.parser||this.setupParserFolder(),this.options&&!this.options.buildVolume||this.setupBuildVolumeFolder(),this.options&&!this.options.devHelpers||this.setupDevHelpers()}reset(){this.gui.destroy(),this.gui=new B,this.gui.title("Dev info"),this.setup()}loadOpenFolders(){this.openFolders=JSON.parse(localStorage.getItem("dev-gui-open")||"{}").open||[]}saveOpenFolders(){this.openFolders=this.gui.foldersRecursive().filter((t=>!t._closed)).map((t=>t._title)),console.log(this.openFolders),localStorage.setItem("dev-gui-open",JSON.stringify({open:this.openFolders}))}setupRedererFolder(){const t=this.gui.addFolder("Render Info");this.openFolders.includes("Render Info")||t.close(),t.onOpenClose((()=>{this.saveOpenFolders()})),t.add(this.watchedObject.renderer.info.render,"triangles").listen(),t.add(this.watchedObject.renderer.info.render,"calls").listen(),t.add(this.watchedObject.renderer.info.render,"lines").listen(),t.add(this.watchedObject.renderer.info.render,"points").listen(),t.add(this.watchedObject.renderer.info.memory,"geometries").listen(),t.add(this.watchedObject.renderer.info.memory,"textures").listen(),t.add(this.watchedObject,"_lastRenderTime").listen()}setupCameraFolder(){const t=this.gui.addFolder("Camera");this.openFolders.includes("Camera")||t.close(),t.onOpenClose((()=>{this.saveOpenFolders()}));const e=t.addFolder("Camera position");e.add(this.watchedObject.camera.position,"x").listen(),e.add(this.watchedObject.camera.position,"y").listen(),e.add(this.watchedObject.camera.position,"z").listen();const n=t.addFolder("Camera rotation");n.add(this.watchedObject.camera.rotation,"x").listen(),n.add(this.watchedObject.camera.rotation,"y").listen(),n.add(this.watchedObject.camera.rotation,"z").listen()}setupParserFolder(){const t=this.gui.addFolder("Parser");this.openFolders.includes("Parser")||t.close(),t.onOpenClose((()=>{this.saveOpenFolders()})),t.add(this.watchedObject.parser,"curZ").listen(),t.add(this.watchedObject.parser,"maxZ").listen(),t.add(this.watchedObject.parser,"tolerance").listen(),t.add(this.watchedObject.parser.layers,"length").name("layers.count").listen(),t.add(this.watchedObject.parser.lines,"length").name("lines.count").listen()}setupBuildVolumeFolder(){const t=this.gui.addFolder("Build Volume");this.openFolders.includes("Build Volume")||t.close(),t.onOpenClose((()=>{this.saveOpenFolders()})),t.add(this.watchedObject.buildVolume,"x").min(0).max(600).listen().onChange((()=>{this.watchedObject.render()})),t.add(this.watchedObject.buildVolume,"y").min(0).max(600).listen().onChange((()=>{this.watchedObject.render()})),t.add(this.watchedObject.buildVolume,"z").min(0).max(600).listen().onChange((()=>{this.watchedObject.render()}))}setupDevHelpers(){const t=this.gui.addFolder("Dev Helpers");this.openFolders.includes("Dev Helpers")||t.close(),t.onOpenClose((()=>{this.saveOpenFolders()})),t.add(this.watchedObject,"_wireframe").listen().onChange((()=>{this.watchedObject.render()})),t.add(this.watchedObject,"render").listen(),t.add(this.watchedObject,"clear").listen()}}class At extends M{constructor(t=[new s],e=.6,n=.2,i=8){super(),this.type="ExtrusionGeometry",this.parameters={points:t,lineWidth:e,lineHeight:n,radialSegments:i,closed:!1};const o=new s,r=new s,a=new d,l=[],c=[],h=[],u=[];function p(a){const[d,h,u]=function(e){const n=t[e],i=new s,o=new s,r=new s,a=new s;i.copy(n).sub(t[e-1]||n).normalize().add((t[e+1]||n).clone().sub(n).normalize()).normalize();let l=Number.MAX_VALUE;const d=Math.abs(i.x),c=Math.abs(i.y),h=Math.abs(i.z);d<=l&&(l=d,o.set(1,0,0));c<=l&&(l=c,o.set(0,1,0));h<=l&&o.set(0,0,1);return a.crossVectors(i,o).normalize(),o.crossVectors(i,a),r.crossVectors(i,o),[n,o,r]}(a);for(let t=0;t<=i;t++){const s=t/i*Math.PI*2,a=Math.sin(s),p=-Math.cos(s);r.x=p*h.x+a*u.x,r.y=p*h.y+a*u.y,r.z=p*h.z+a*u.z,r.normalize(),c.push(r.x,r.y,r.z),o.x=d.x+e*r.x*.5,o.y=d.y+e*r.y*.5,o.z=d.z+n*r.z*.5,l.push(o.x,o.y,o.z)}}!function(){for(let e=0;e<t.length;e++)p(e);p(!1===closed?t.length-1:0),function(){for(let e=0;e<t.length;e++)for(let n=0;n<=i;n++)a.x=e/t.length,a.y=n/i,h.push(a.x,a.y)}(),function(){for(let e=1;e<t.length;e++)for(let t=1;t<=i;t++){const n=(i+1)*(e-1)+(t-1),s=(i+1)*e+(t-1),o=(i+1)*e+t,r=(i+1)*(e-1)+t;u.push(n,s,r),u.push(s,o,r)}}()}(),this.setIndex(u),this.setAttribute("position",new g(l,3)),this.setAttribute("normal",new g(c,3)),this.setAttribute("uv",new g(h,2))}}class Tt{static get initial(){const t=new Tt;return Object.assign(t,{x:0,y:0,z:0,r:0,e:0,i:0,j:0,t:0}),t}}const zt={h:0,s:0,l:0};class _t{constructor(t){var e,n,i,s,o,r,a,l,d;if(this.minLayerThreshold=.05,this.renderExtrusion=!0,this.renderTravel=!1,this.renderTubes=!1,this.extrusionWidth=.6,this.singleLayerMode=!1,this.initialCameraPosition=[-100,400,450],this.debug=!1,this.inches=!1,this.nonTravelmoves=[],this.disableGradient=!1,this.state=Tt.initial,this.beyondFirstMove=!1,this.disposables=[],this._extrusionColor=_t.defaultExtrusionColor,this.renderLayerIndex=0,this._geometries={},this._backgroundColor=new O(14737632),this._travelColor=new O(10027008),this._toolColors={},this.devMode=!1,this._lastRenderTime=0,this._wireframe=!1,this.minLayerThreshold=null!==(e=t.minLayerThreshold)&&void 0!==e?e:this.minLayerThreshold,this.parser=new X(this.minLayerThreshold),this.scene=new z,this.scene.background=this._backgroundColor,void 0!==t.backgroundColor&&(this.backgroundColor=new O(t.backgroundColor)),this.targetId=t.targetId,this.endLayer=t.endLayer,this.startLayer=t.startLayer,this.lineWidth=t.lineWidth,this.lineHeight=t.lineHeight,this.buildVolume=t.buildVolume,this.initialCameraPosition=null!==(n=t.initialCameraPosition)&&void 0!==n?n:this.initialCameraPosition,this.debug=null!==(i=t.debug)&&void 0!==i?i:this.debug,this.renderExtrusion=null!==(s=t.renderExtrusion)&&void 0!==s?s:this.renderExtrusion,this.renderTravel=null!==(o=t.renderTravel)&&void 0!==o?o:this.renderTravel,this.nonTravelmoves=null!==(r=t.nonTravelMoves)&&void 0!==r?r:this.nonTravelmoves,this.renderTubes=null!==(a=t.renderTubes)&&void 0!==a?a:this.renderTubes,this.extrusionWidth=null!==(l=t.extrusionWidth)&&void 0!==l?l:this.extrusionWidth,this.devMode=null!==(d=t.devMode)&&void 0!==d?d:this.devMode,this.stats=this.devMode?new Ot:void 0,void 0!==t.extrusionColor&&(this.extrusionColor=t.extrusionColor),void 0!==t.travelColor&&(this.travelColor=new O(t.travelColor)),void 0!==t.topLayerColor&&(this.topLayerColor=new O(t.topLayerColor)),void 0!==t.lastSegmentColor&&(this.lastSegmentColor=new O(t.lastSegmentColor)),t.toolColors){this._toolColors={};for(const[e,n]of Object.entries(t.toolColors))this._toolColors[parseInt(e)]=new O(n)}if(void 0!==t.disableGradient&&(this.disableGradient=t.disableGradient),console.info("Using THREE r"+_),console.debug("opts",t),this.targetId&&console.warn("`targetId` is deprecated and will removed in the future. Use `canvas` instead."),t.canvas)this.canvas=t.canvas,this.renderer=new j({canvas:this.canvas,preserveDrawingBuffer:!0});else{if(!this.targetId)throw Error("Set either opts.canvas or opts.targetId");const t=document.getElementById(this.targetId);if(!t)throw new Error("Unable to find element "+this.targetId);this.renderer=new j({preserveDrawingBuffer:!0}),this.canvas=this.renderer.domElement,t.appendChild(this.canvas)}this.camera=new P(25,this.canvas.offsetWidth/this.canvas.offsetHeight,10,5e3),this.camera.position.fromArray(this.initialCameraPosition);const c=this.camera.far,h=.8*c;this.scene.fog=new I(this._backgroundColor,h,c),this.resize(),this.controls=new nt(this.camera,this.renderer.domElement),this.initScene(),this.animate(),t.allowDragNDrop&&this._enableDropHandler(),this.initStats()}get extrusionColor(){return this._extrusionColor}set extrusionColor(t){if(Array.isArray(t)){this._extrusionColor=[];for(const[e,n]of t.entries())this._extrusionColor[e]=new O(n)}else this._extrusionColor=new O(t)}get currentToolColor(){var t;return void 0===this._extrusionColor?_t.defaultExtrusionColor:this._extrusionColor instanceof O?this._extrusionColor:null!==(t=this._extrusionColor[this.state.t])&&void 0!==t?t:_t.defaultExtrusionColor}get backgroundColor(){return this._backgroundColor}set backgroundColor(t){this._backgroundColor=new O(t),this.scene.background=this._backgroundColor}get travelColor(){return this._travelColor}set travelColor(t){this._travelColor=new O(t)}get topLayerColor(){return this._topLayerColor}set topLayerColor(t){this._topLayerColor=void 0!==t?new O(t):void 0}get lastSegmentColor(){return this._lastSegmentColor}set lastSegmentColor(t){this._lastSegmentColor=void 0!==t?new O(t):void 0}get layers(){return[this.parser.preamble].concat(this.parser.layers.concat())}get maxLayerIndex(){var t;return(null!==(t=this.endLayer)&&void 0!==t?t:this.layers.length)-1}get minLayerIndex(){var t;return this.singleLayerMode?this.maxLayerIndex:(null!==(t=this.startLayer)&&void 0!==t?t:0)-1}animate(){var t;this.animationFrameId=requestAnimationFrame((()=>this.animate())),this.controls.update(),this.renderer.render(this.scene,this.camera),null===(t=this.stats)||void 0===t||t.update()}processGCode(t){this.parser.parseGCode(t),this.render()}initScene(){for(;this.scene.children.length>0;)this.scene.remove(this.scene.children[0]);for(;this.disposables.length>0;){const t=this.disposables.pop();t&&t.dispose()}if(this.debug&&this.buildVolume){const t=new D(Math.max(this.buildVolume.x/2,this.buildVolume.y/2)+20);this.scene.add(t)}if(this.buildVolume&&this.drawBuildVolume(),this.renderTubes){console.warn("Volumetric rendering is experimental. It may not work as expected or change in the future.");const t=new R(13421772,.3*Math.PI),e=new F(16777215,Math.PI,void 0,.001);e.position.set(0,500,500),this.scene.add(t),this.scene.add(e)}}createGroup(t){const e=new N;return e.name=t,e.quaternion.setFromEuler(new H(-Math.PI/2,0,0)),this.buildVolume?e.position.set(-this.buildVolume.x/2,0,this.buildVolume.y/2):e.position.set(-100,0,100),e}render(){const t=performance.now();this.group=this.createGroup("allLayers"),this.state=Tt.initial,this.initScene();for(let t=0;t<this.layers.length;t++)this.renderLayer(t);this.batchGeometries(),this.scene.add(this.group),this.renderer.render(this.scene,this.camera),this._lastRenderTime=performance.now()-t}renderAnimated(t=1){return V(this,void 0,void 0,(function*(){return this.initScene(),this.renderLayerIndex=0,this.renderFrameLoop(t>0?t:1)}))}renderFrameLoop(t){return new Promise((e=>{const n=()=>{this.renderLayerIndex>this.layers.length-1?e():(this.renderFrame(t),requestAnimationFrame(n))};n()}))}renderFrame(t){this.group=this.createGroup("layer"+this.renderLayerIndex);for(let e=0;e<t&&this.renderLayerIndex+e<this.layers.length;e++)this.renderLayer(this.renderLayerIndex),this.renderLayerIndex++;this.batchGeometries(),this.scene.add(this.group)}renderLayer(t){var e,n,i,s,o,r,a,l;if(t>this.maxLayerIndex)return;const d=this.layers[t],c={extrusion:[],travel:[],z:this.state.z,height:d.height};for(const h of d.commands)if("g20"!=h.gcode){if(h.gcode.startsWith("t")){this.doRenderExtrusion(c,t),c.extrusion=[];const e=h;this.state.t=e.toolIndex}else if(["g0","g00","g1","g01","g2","g02","g3","g03"].indexOf(h.gcode)>-1){const d=h,u={x:null!==(e=d.params.x)&&void 0!==e?e:this.state.x,y:null!==(n=d.params.y)&&void 0!==n?n:this.state.y,z:null!==(i=d.params.z)&&void 0!==i?i:this.state.z,r:null!==(s=d.params.r)&&void 0!==s?s:this.state.r,e:null!==(o=d.params.e)&&void 0!==o?o:this.state.e,i:null!==(r=d.params.i)&&void 0!==r?r:this.state.i,j:null!==(a=d.params.j)&&void 0!==a?a:this.state.j,t:this.state.t};if(t>=this.minLayerIndex){const t=(null!==(l=d.params.e)&&void 0!==l?l:0)>0||this.nonTravelmoves.indexOf(h.gcode)>-1;(u.x!=this.state.x||u.y!=this.state.y||u.z!=this.state.z)&&(t&&this.renderExtrusion||!t&&this.renderTravel)&&("g2"==h.gcode||"g3"==h.gcode||"g02"==h.gcode||"g03"==h.gcode?this.addArcSegment(c,this.state,u,t,"g2"==h.gcode||"g02"==h.gcode):this.addLineSegment(c,this.state,u,t))}this.state.x=u.x,this.state.y=u.y,this.state.z=u.z,this.beyondFirstMove||(this.beyondFirstMove=!0)}}else this.setInches();this.doRenderExtrusion(c,t)}doRenderExtrusion(t,e){var n,i;if(this.renderExtrusion){let s=this.currentToolColor;if(!this.singleLayerMode&&!this.renderTubes&&!this.disableGradient){const t=.1+.7*e/this.layers.length;s.getHSL(zt),s=(new O).setHSL(zt.h,zt.s,t)}if(e==this.layers.length-1){const e=null!==(n=this._topLayerColor)&&void 0!==n?n:s,o=null!==(i=this._lastSegmentColor)&&void 0!==i?i:e,r=t.extrusion.splice(-3),a=t.extrusion.splice(-3);this.renderTubes?(this.addTubeLine(t.extrusion,e.getHex(),t.height),this.addTubeLine([...a,...r],o.getHex(),t.height)):(this.addLine(t.extrusion,e.getHex()),this.addLine([...a,...r],o.getHex()))}else this.renderTubes?this.addTubeLine(t.extrusion,s.getHex(),t.height):this.addLine(t.extrusion,s.getHex())}this.renderTravel&&this.addLine(t.travel,this._travelColor.getHex())}setInches(){this.beyondFirstMove?console.warn("Switching units after movement is already made is discouraged and is not supported."):this.inches=!0}drawBuildVolume(){if(!this.buildVolume)return;this.scene.add(new Et(this.buildVolume.x,10,this.buildVolume.y,10));const t=Lt(this.buildVolume.x,this.buildVolume.z,this.buildVolume.y,8947848);t.position.setY(this.buildVolume.z/2),this.scene.add(t)}clear(){this.resetState(),this.parser=new X(this.minLayerThreshold)}resetState(){var t;this.startLayer=1,this.endLayer=1/0,this.singleLayerMode=!1,this.beyondFirstMove=!1,this.state=Tt.initial,null===(t=this.devGui)||void 0===t||t.reset(),this._geometries={}}resize(){const[t,e]=[this.canvas.offsetWidth,this.canvas.offsetHeight];this.camera.aspect=t/e,this.camera.updateProjectionMatrix(),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(t,e,!1)}addLineSegment(t,e,n,i){(i?t.extrusion:t.travel).push(e.x,e.y,e.z,n.x,n.y,n.z)}addArcSegment(t,e,n,i,s){const o=i?t.extrusion:t.travel,r=e.x,a=e.y,l=e.z,d=n.x,c=n.y,h=n.z;let u=n.r,p=n.i,m=n.j;if(u){const t=d-r,e=c-a,n=Math.sqrt(Math.pow(t/2,2)+Math.pow(e/2,2));u=Math.max(u,n);const i=Math.pow(t,2)+Math.pow(e,2),o=Math.pow(u,2)-i/4;let l=Math.sqrt(o/i);(s&&u<0||!s&&u>0)&&(l=-l),p=t/2+e*l,m=e/2-t*l}const f=r==d&&a==c,g=r+p,v=a+m,y=Math.sqrt(p*p+m*m),b=Math.atan2(-m,-p),w=Math.atan2(c-v,d-g);let x;f?x=2*Math.PI:(x=s?b-w:w-b,x<0&&(x+=2*Math.PI));let S=y*x/1.8;this.inches&&(S*=25),S<1&&(S=1);let E=x/S;E*=s?-1:1;const L=[];L.push({x:r,y:a,z:l});const C=(l-h)/S;let O=r,M=a,A=l,T=b;for(let t=0;t<S-1;t++)T+=E,O=g+y*Math.cos(T),M=v+y*Math.sin(T),A+=C,L.push({x:O,y:M,z:A});L.push({x:n.x,y:n.y,z:n.z});for(let t=0;t<L.length-1;t++)o.push(L[t].x,L[t].y,L[t].z,L[t+1].x,L[t+1].y,L[t+1].z)}addLine(t,e){var n;if("number"==typeof this.lineWidth&&this.lineWidth>0)return void this.addThickLine(t,e);const i=new M;i.setAttribute("position",new g(t,3)),this.disposables.push(i);const s=new A({color:e});this.disposables.push(s);const o=new C(i,s);null===(n=this.group)||void 0===n||n.add(o)}addTubeLine(t,e,n=.2){let i=[];const o=[];for(let e=0;e<t.length;e+=6){const n=t.slice(e,e+9),r=new s(n[0],n[1],n[2]),a=new s(n[3],n[4],n[5]),l=new s(n[6],n[7],n[8]);i.push(r),a.equals(l)||(i.push(a),o.push(i),i=[])}o.forEach((t=>{var i;const s=new At(t,this.extrusionWidth,this.lineHeight||n,4);(i=this._geometries)[e]||(i[e]=[]),this._geometries[e].push(s)}))}addThickLine(t,e){var n;if(!t.length||!this.lineWidth)return;const i=new rt;this.disposables.push(i);const s=new it({color:e,linewidth:this.lineWidth/(1e3*window.devicePixelRatio)});this.disposables.push(s),i.setPositions(t);const o=new St(i,s);null===(n=this.group)||void 0===n||n.add(o)}dispose(){this.disposables.forEach((t=>t.dispose())),this.disposables=[],this.controls.dispose(),this.renderer.dispose(),this.cancelAnimation()}cancelAnimation(){void 0!==this.animationFrameId&&cancelAnimationFrame(this.animationFrameId),this.animationFrameId=void 0}_enableDropHandler(){console.warn("Drag and drop is deprecated as a library feature. See the demo how to implement your own."),this.canvas.addEventListener("dragover",(t=>{t.stopPropagation(),t.preventDefault(),t.dataTransfer&&(t.dataTransfer.dropEffect="copy"),this.canvas.classList.add("dragging")})),this.canvas.addEventListener("dragleave",(t=>{t.stopPropagation(),t.preventDefault(),this.canvas.classList.remove("dragging")})),this.canvas.addEventListener("drop",(t=>V(this,void 0,void 0,(function*(){var e,n;t.stopPropagation(),t.preventDefault(),this.canvas.classList.remove("dragging");const i=(null!==(n=null===(e=t.dataTransfer)||void 0===e?void 0:e.files)&&void 0!==n?n:[])[0];this.clear(),yield this._readFromStream(i.stream()),this.render()}))))}batchGeometries(){if(this._geometries)for(const t in this._geometries){const e=this.createBatchMesh(parseInt(t));for(;this._geometries[t].length>0;){const n=this._geometries[t].pop();e.addGeometry(n)}}}createBatchMesh(t){var e;const n=this._geometries[t],i=new U({color:t,wireframe:this._wireframe});this.disposables.push(i);const s=n.reduce(((t,e)=>3*e.attributes.position.count+t),0),o=new k(n.length,s,void 0,i);return this.disposables.push(o),null===(e=this.group)||void 0===e||e.add(o),o}_readFromStream(t){var e,n;return V(this,void 0,void 0,(function*(){const i=t.getReader();let s,o="",r=0;do{console.debug("reading from stream"),s=yield i.read(),r+=null!==(n=null===(e=s.value)||void 0===e?void 0:e.length)&&void 0!==n?n:0;const t=(a=s.value,new TextDecoder("utf-8").decode(a)),l=t.lastIndexOf("\n"),d=t.slice(0,l);this.parser.parseGCode(o+d),o=t.slice(l)}while(!s.done);var a;console.debug("read from stream",r)}))}initGui(){"boolean"==typeof this.devMode&&!0===this.devMode?this.devGui=new Mt(this):"object"==typeof this.devMode&&(this.devGui=new Mt(this,this.devMode))}initStats(){var t;this.stats&&("object"==typeof this.devMode&&(this.statsContainer=this.devMode.statsContainer),(null!==(t=this.statsContainer)&&void 0!==t?t:document.body).appendChild(this.stats.dom),this.stats.dom.classList.add("stats"),this.initGui())}}_t.defaultExtrusionColor=new O("hotpink");const jt=function(t){return new _t(t)};export{_t as WebGLPreview,jt as init};
