!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three"),require("lil-gui")):"function"==typeof define&&define.amd?define(["exports","three","lil-gui"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).GCodePreview={},t.THREE,t.lilGui)}(this,(function(t,e,n){"use strict";function i(t,e,n,i){return new(n||(n=Promise))((function(s,o){function r(t){try{l(i.next(t))}catch(t){o(t)}}function a(t){try{l(i.throw(t))}catch(t){o(t)}}function l(t){var e;t.done?s(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(r,a)}l((i=i.apply(t,e||[])).next())}))}"function"==typeof SuppressedError&&SuppressedError;class s{constructor(t,e,n,i){this.size=t,this.width=e,this.height=n,this.charLength=i,this.chars=""}static parse(t){const e=t.split(" "),n=e[0],i=n.split("x");return new s(n,+i[0],+i[1],+e[1])}get src(){return"data:image/jpeg;base64,"+this.chars}get isValid(){return this.chars.length==this.charLength&&/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(this.chars)}}class o{constructor(t,e,n,i){this.src=t,this.gcode=e,this.params=n,this.comment=i}}class r extends o{constructor(t,e,n,i){super(t,e,n,i),this.params=n}}class a extends o{constructor(t,e,n,i){super(t,e,void 0,n),this.toolIndex=i}}class l{constructor(t,e,n,i=0){this.layer=t,this.commands=e,this.lineNumber=n,this.height=i}}class d{constructor(t){this.lines=[],this.preamble=new l(-1,[],0),this.layers=[],this.curZ=0,this.maxZ=0,this.metadata={thumbnails:{}},this.tolerance=0,this.tolerance=null!=t?t:this.tolerance}parseGCode(t){const e=Array.isArray(t)?t:t.split("\n");this.lines=this.lines.concat(e);const n=this.lines2commands(e);this.groupIntoLayers(n);const i=this.parseMetadata(n.filter((t=>t.comment))).thumbnails;for(const[t,e]of Object.entries(i))this.metadata.thumbnails[t]=e;return{layers:this.layers,metadata:this.metadata}}lines2commands(t){return t.map((t=>this.parseCommand(t)))}parseCommand(t,e=!0){var n;const i=t.trim().split(";"),s=i[0],l=e&&i[1]||void 0,d=s.split(/([a-zA-Z])/g).slice(1).map((t=>t.trim())),c=d.length?`${null===(n=d[0])||void 0===n?void 0:n.toLowerCase()}${d[1]}`:"",h=this.parseParams(d.slice(2));switch(c){case"g0":case"g00":case"g1":case"g01":case"g2":case"g02":case"g3":case"g03":return new r(t,c,h,l);case"t0":return new a(t,c,l,0);case"t1":return new a(t,c,l,1);case"t2":return new a(t,c,l,2);case"t3":return new a(t,c,l,3);case"t4":return new a(t,c,l,4);case"t5":return new a(t,c,l,5);case"t6":return new a(t,c,l,6);case"t7":return new a(t,c,l,7);default:return new o(t,c,h,l)}}parseMove(t){return t.reduce(((t,e)=>{const n=e.charAt(0).toLowerCase();return"x"!=n&&"y"!=n&&"z"!=n&&"e"!=n&&"r"!=n&&"f"!=n&&"i"!=n&&"j"!=n||(t[n]=parseFloat(e.slice(1))),t}),{})}isAlpha(t){const e=t.charCodeAt(0);return e>=97&&e<=122||e>=65&&e<=90}parseParams(t){return t.reduce(((t,e,n,i)=>{if(n%2==0)return t;let s=i[n-1];return s=s.toLowerCase(),this.isAlpha(s)&&(t[s]=parseFloat(e)),t}),{})}groupIntoLayers(t){var e;for(let n=0;n<t.length;n++){const i=t[n];if(i instanceof r){const t=i.params;if(t.z&&(this.curZ=t.z),(null!==(e=t.e)&&void 0!==e?e:0)>0&&(null!=t.x||null!=t.y)&&Math.abs(this.curZ-(this.maxZ||-1/0))>this.tolerance){const t=Math.abs(this.curZ-this.maxZ);this.maxZ=this.curZ,this.layers.push(new l(this.layers.length,[],n,t))}}this.maxLayer.commands.push(i)}return this.layers}get maxLayer(){var t;return null!==(t=this.layers[this.layers.length-1])&&void 0!==t?t:this.preamble}parseMetadata(t){const e={};let n;for(const i of t){const t=i.comment;if(!t)continue;const o=t.indexOf("thumbnail begin"),r=t.indexOf("thumbnail end");o>-1?n=s.parse(t.slice(o+15).trim()):n&&(-1==r?n.chars+=t.trim():(n.isValid&&(e[n.size]=n),n=void 0))}return{thumbnails:e}}}d.prototype.parseGcode=d.prototype.parseGCode;const c={type:"change"},h={type:"start"},u={type:"end"},p=new e.Ray,m=new e.Plane,f=Math.cos(70*e.MathUtils.DEG2RAD);class g extends e.EventDispatcher{constructor(t,n){super(),this.object=t,this.domElement=n,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new e.Vector3,this.cursor=new e.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minTargetRadius=0,this.maxTargetRadius=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:e.MOUSE.ROTATE,MIDDLE:e.MOUSE.DOLLY,RIGHT:e.MOUSE.PAN},this.touches={ONE:e.TOUCH.ROTATE,TWO:e.TOUCH.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return a.phi},this.getAzimuthalAngle=function(){return a.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(t){t.addEventListener("keydown",$),this._domElementKeyEvents=t},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",$),this._domElementKeyEvents=null},this.saveState=function(){i.target0.copy(i.target),i.position0.copy(i.object.position),i.zoom0=i.object.zoom},this.reset=function(){i.target.copy(i.target0),i.object.position.copy(i.position0),i.object.zoom=i.zoom0,i.object.updateProjectionMatrix(),i.dispatchEvent(c),i.update(),o=s.NONE},this.update=function(){const n=new e.Vector3,h=(new e.Quaternion).setFromUnitVectors(t.up,new e.Vector3(0,1,0)),u=h.clone().invert(),v=new e.Vector3,b=new e.Quaternion,y=new e.Vector3,w=2*Math.PI;return function(x=null){const S=i.object.position;n.copy(S).sub(i.target),n.applyQuaternion(h),a.setFromVector3(n),i.autoRotate&&o===s.NONE&&P(function(t){return null!==t?2*Math.PI/60*i.autoRotateSpeed*t:2*Math.PI/60/60*i.autoRotateSpeed}(x)),i.enableDamping?(a.theta+=l.theta*i.dampingFactor,a.phi+=l.phi*i.dampingFactor):(a.theta+=l.theta,a.phi+=l.phi);let E=i.minAzimuthAngle,L=i.maxAzimuthAngle;isFinite(E)&&isFinite(L)&&(E<-Math.PI?E+=w:E>Math.PI&&(E-=w),L<-Math.PI?L+=w:L>Math.PI&&(L-=w),a.theta=E<=L?Math.max(E,Math.min(L,a.theta)):a.theta>(E+L)/2?Math.max(E,a.theta):Math.min(L,a.theta)),a.phi=Math.max(i.minPolarAngle,Math.min(i.maxPolarAngle,a.phi)),a.makeSafe(),!0===i.enableDamping?i.target.addScaledVector(g,i.dampingFactor):i.target.add(g),i.target.sub(i.cursor),i.target.clampLength(i.minTargetRadius,i.maxTargetRadius),i.target.add(i.cursor),i.zoomToCursor&&O||i.object.isOrthographicCamera?a.radius=B(a.radius):a.radius=B(a.radius*d),n.setFromSpherical(a),n.applyQuaternion(u),S.copy(i.target).add(n),i.object.lookAt(i.target),!0===i.enableDamping?(l.theta*=1-i.dampingFactor,l.phi*=1-i.dampingFactor,g.multiplyScalar(1-i.dampingFactor)):(l.set(0,0,0),g.set(0,0,0));let C=!1;if(i.zoomToCursor&&O){let s=null;if(i.object.isPerspectiveCamera){const t=n.length();s=B(t*d);const e=t-s;i.object.position.addScaledVector(M,e),i.object.updateMatrixWorld()}else if(i.object.isOrthographicCamera){const t=new e.Vector3(A.x,A.y,0);t.unproject(i.object),i.object.zoom=Math.max(i.minZoom,Math.min(i.maxZoom,i.object.zoom/d)),i.object.updateProjectionMatrix(),C=!0;const o=new e.Vector3(A.x,A.y,0);o.unproject(i.object),i.object.position.sub(o).add(t),i.object.updateMatrixWorld(),s=n.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),i.zoomToCursor=!1;null!==s&&(this.screenSpacePanning?i.target.set(0,0,-1).transformDirection(i.object.matrix).multiplyScalar(s).add(i.object.position):(p.origin.copy(i.object.position),p.direction.set(0,0,-1).transformDirection(i.object.matrix),Math.abs(i.object.up.dot(p.direction))<f?t.lookAt(i.target):(m.setFromNormalAndCoplanarPoint(i.object.up,i.target),p.intersectPlane(m,i.target))))}else i.object.isOrthographicCamera&&(i.object.zoom=Math.max(i.minZoom,Math.min(i.maxZoom,i.object.zoom/d)),i.object.updateProjectionMatrix(),C=!0);return d=1,O=!1,!!(C||v.distanceToSquared(i.object.position)>r||8*(1-b.dot(i.object.quaternion))>r||y.distanceToSquared(i.target)>0)&&(i.dispatchEvent(c),v.copy(i.object.position),b.copy(i.object.quaternion),y.copy(i.target),!0)}}(),this.dispose=function(){i.domElement.removeEventListener("contextmenu",tt),i.domElement.removeEventListener("pointerdown",X),i.domElement.removeEventListener("pointercancel",J),i.domElement.removeEventListener("wheel",Q),i.domElement.removeEventListener("pointermove",q),i.domElement.removeEventListener("pointerup",J),null!==i._domElementKeyEvents&&(i._domElementKeyEvents.removeEventListener("keydown",$),i._domElementKeyEvents=null)};const i=this,s={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let o=s.NONE;const r=1e-6,a=new e.Spherical,l=new e.Spherical;let d=1;const g=new e.Vector3,v=new e.Vector2,b=new e.Vector2,y=new e.Vector2,w=new e.Vector2,x=new e.Vector2,S=new e.Vector2,E=new e.Vector2,L=new e.Vector2,C=new e.Vector2,M=new e.Vector3,A=new e.Vector2;let O=!1;const T=[],_={};function z(){return Math.pow(.95,i.zoomSpeed)}function P(t){l.theta-=t}function j(t){l.phi-=t}const I=function(){const t=new e.Vector3;return function(e,n){t.setFromMatrixColumn(n,0),t.multiplyScalar(-e),g.add(t)}}(),V=function(){const t=new e.Vector3;return function(e,n){!0===i.screenSpacePanning?t.setFromMatrixColumn(n,1):(t.setFromMatrixColumn(n,0),t.crossVectors(i.object.up,t)),t.multiplyScalar(e),g.add(t)}}(),D=function(){const t=new e.Vector3;return function(e,n){const s=i.domElement;if(i.object.isPerspectiveCamera){const o=i.object.position;t.copy(o).sub(i.target);let r=t.length();r*=Math.tan(i.object.fov/2*Math.PI/180),I(2*e*r/s.clientHeight,i.object.matrix),V(2*n*r/s.clientHeight,i.object.matrix)}else i.object.isOrthographicCamera?(I(e*(i.object.right-i.object.left)/i.object.zoom/s.clientWidth,i.object.matrix),V(n*(i.object.top-i.object.bottom)/i.object.zoom/s.clientHeight,i.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),i.enablePan=!1)}}();function F(t){i.object.isPerspectiveCamera||i.object.isOrthographicCamera?d/=t:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),i.enableZoom=!1)}function U(t){i.object.isPerspectiveCamera||i.object.isOrthographicCamera?d*=t:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),i.enableZoom=!1)}function R(t){if(!i.zoomToCursor)return;O=!0;const e=i.domElement.getBoundingClientRect(),n=t.clientX-e.left,s=t.clientY-e.top,o=e.width,r=e.height;A.x=n/o*2-1,A.y=-s/r*2+1,M.set(A.x,A.y,1).unproject(i.object).sub(i.object.position).normalize()}function B(t){return Math.max(i.minDistance,Math.min(i.maxDistance,t))}function H(t){v.set(t.clientX,t.clientY)}function N(t){w.set(t.clientX,t.clientY)}function k(){if(1===T.length)v.set(T[0].pageX,T[0].pageY);else{const t=.5*(T[0].pageX+T[1].pageX),e=.5*(T[0].pageY+T[1].pageY);v.set(t,e)}}function G(){if(1===T.length)w.set(T[0].pageX,T[0].pageY);else{const t=.5*(T[0].pageX+T[1].pageX),e=.5*(T[0].pageY+T[1].pageY);w.set(t,e)}}function W(){const t=T[0].pageX-T[1].pageX,e=T[0].pageY-T[1].pageY,n=Math.sqrt(t*t+e*e);E.set(0,n)}function Y(t){if(1==T.length)b.set(t.pageX,t.pageY);else{const e=nt(t),n=.5*(t.pageX+e.x),i=.5*(t.pageY+e.y);b.set(n,i)}y.subVectors(b,v).multiplyScalar(i.rotateSpeed);const e=i.domElement;P(2*Math.PI*y.x/e.clientHeight),j(2*Math.PI*y.y/e.clientHeight),v.copy(b)}function Z(t){if(1===T.length)x.set(t.pageX,t.pageY);else{const e=nt(t),n=.5*(t.pageX+e.x),i=.5*(t.pageY+e.y);x.set(n,i)}S.subVectors(x,w).multiplyScalar(i.panSpeed),D(S.x,S.y),w.copy(x)}function K(t){const e=nt(t),n=t.pageX-e.x,s=t.pageY-e.y,o=Math.sqrt(n*n+s*s);L.set(0,o),C.set(0,Math.pow(L.y/E.y,i.zoomSpeed)),F(C.y),E.copy(L)}function X(t){!1!==i.enabled&&(0===T.length&&(i.domElement.setPointerCapture(t.pointerId),i.domElement.addEventListener("pointermove",q),i.domElement.addEventListener("pointerup",J)),function(t){T.push(t)}(t),"touch"===t.pointerType?function(t){switch(et(t),T.length){case 1:switch(i.touches.ONE){case e.TOUCH.ROTATE:if(!1===i.enableRotate)return;k(),o=s.TOUCH_ROTATE;break;case e.TOUCH.PAN:if(!1===i.enablePan)return;G(),o=s.TOUCH_PAN;break;default:o=s.NONE}break;case 2:switch(i.touches.TWO){case e.TOUCH.DOLLY_PAN:if(!1===i.enableZoom&&!1===i.enablePan)return;i.enableZoom&&W(),i.enablePan&&G(),o=s.TOUCH_DOLLY_PAN;break;case e.TOUCH.DOLLY_ROTATE:if(!1===i.enableZoom&&!1===i.enableRotate)return;i.enableZoom&&W(),i.enableRotate&&k(),o=s.TOUCH_DOLLY_ROTATE;break;default:o=s.NONE}break;default:o=s.NONE}o!==s.NONE&&i.dispatchEvent(h)}(t):function(t){let n;switch(t.button){case 0:n=i.mouseButtons.LEFT;break;case 1:n=i.mouseButtons.MIDDLE;break;case 2:n=i.mouseButtons.RIGHT;break;default:n=-1}switch(n){case e.MOUSE.DOLLY:if(!1===i.enableZoom)return;!function(t){R(t),E.set(t.clientX,t.clientY)}(t),o=s.DOLLY;break;case e.MOUSE.ROTATE:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===i.enablePan)return;N(t),o=s.PAN}else{if(!1===i.enableRotate)return;H(t),o=s.ROTATE}break;case e.MOUSE.PAN:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===i.enableRotate)return;H(t),o=s.ROTATE}else{if(!1===i.enablePan)return;N(t),o=s.PAN}break;default:o=s.NONE}o!==s.NONE&&i.dispatchEvent(h)}(t))}function q(t){!1!==i.enabled&&("touch"===t.pointerType?function(t){switch(et(t),o){case s.TOUCH_ROTATE:if(!1===i.enableRotate)return;Y(t),i.update();break;case s.TOUCH_PAN:if(!1===i.enablePan)return;Z(t),i.update();break;case s.TOUCH_DOLLY_PAN:if(!1===i.enableZoom&&!1===i.enablePan)return;!function(t){i.enableZoom&&K(t),i.enablePan&&Z(t)}(t),i.update();break;case s.TOUCH_DOLLY_ROTATE:if(!1===i.enableZoom&&!1===i.enableRotate)return;!function(t){i.enableZoom&&K(t),i.enableRotate&&Y(t)}(t),i.update();break;default:o=s.NONE}}(t):function(t){switch(o){case s.ROTATE:if(!1===i.enableRotate)return;!function(t){b.set(t.clientX,t.clientY),y.subVectors(b,v).multiplyScalar(i.rotateSpeed);const e=i.domElement;P(2*Math.PI*y.x/e.clientHeight),j(2*Math.PI*y.y/e.clientHeight),v.copy(b),i.update()}(t);break;case s.DOLLY:if(!1===i.enableZoom)return;!function(t){L.set(t.clientX,t.clientY),C.subVectors(L,E),C.y>0?F(z()):C.y<0&&U(z()),E.copy(L),i.update()}(t);break;case s.PAN:if(!1===i.enablePan)return;!function(t){x.set(t.clientX,t.clientY),S.subVectors(x,w).multiplyScalar(i.panSpeed),D(S.x,S.y),w.copy(x),i.update()}(t)}}(t))}function J(t){!function(t){delete _[t.pointerId];for(let e=0;e<T.length;e++)if(T[e].pointerId==t.pointerId)return void T.splice(e,1)}(t),0===T.length&&(i.domElement.releasePointerCapture(t.pointerId),i.domElement.removeEventListener("pointermove",q),i.domElement.removeEventListener("pointerup",J)),i.dispatchEvent(u),o=s.NONE}function Q(t){!1!==i.enabled&&!1!==i.enableZoom&&o===s.NONE&&(t.preventDefault(),i.dispatchEvent(h),function(t){R(t),t.deltaY<0?U(z()):t.deltaY>0&&F(z()),i.update()}(t),i.dispatchEvent(u))}function $(t){!1!==i.enabled&&!1!==i.enablePan&&function(t){let e=!1;switch(t.code){case i.keys.UP:t.ctrlKey||t.metaKey||t.shiftKey?j(2*Math.PI*i.rotateSpeed/i.domElement.clientHeight):D(0,i.keyPanSpeed),e=!0;break;case i.keys.BOTTOM:t.ctrlKey||t.metaKey||t.shiftKey?j(-2*Math.PI*i.rotateSpeed/i.domElement.clientHeight):D(0,-i.keyPanSpeed),e=!0;break;case i.keys.LEFT:t.ctrlKey||t.metaKey||t.shiftKey?P(2*Math.PI*i.rotateSpeed/i.domElement.clientHeight):D(i.keyPanSpeed,0),e=!0;break;case i.keys.RIGHT:t.ctrlKey||t.metaKey||t.shiftKey?P(-2*Math.PI*i.rotateSpeed/i.domElement.clientHeight):D(-i.keyPanSpeed,0),e=!0}e&&(t.preventDefault(),i.update())}(t)}function tt(t){!1!==i.enabled&&t.preventDefault()}function et(t){let n=_[t.pointerId];void 0===n&&(n=new e.Vector2,_[t.pointerId]=n),n.set(t.pageX,t.pageY)}function nt(t){const e=t.pointerId===T[0].pointerId?T[1]:T[0];return _[e.pointerId]}i.domElement.addEventListener("contextmenu",tt),i.domElement.addEventListener("pointerdown",X),i.domElement.addEventListener("pointercancel",J),i.domElement.addEventListener("wheel",Q,{passive:!1}),this.update()}}e.UniformsLib.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new e.Vector2(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}},e.ShaderLib.line={uniforms:e.UniformsUtils.merge([e.UniformsLib.common,e.UniformsLib.fog,e.UniformsLib.line]),vertexShader:"\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",fragmentShader:"\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t"};class v extends e.ShaderMaterial{constructor(t){super({type:"LineMaterial",uniforms:e.UniformsUtils.clone(e.ShaderLib.line.uniforms),vertexShader:e.ShaderLib.line.vertexShader,fragmentShader:e.ShaderLib.line.fragmentShader,clipping:!0}),this.isLineMaterial=!0,this.setValues(t)}get color(){return this.uniforms.diffuse.value}set color(t){this.uniforms.diffuse.value=t}get worldUnits(){return"WORLD_UNITS"in this.defines}set worldUnits(t){!0===t?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}get linewidth(){return this.uniforms.linewidth.value}set linewidth(t){this.uniforms.linewidth&&(this.uniforms.linewidth.value=t)}get dashed(){return"USE_DASH"in this.defines}set dashed(t){!0===t!==this.dashed&&(this.needsUpdate=!0),!0===t?this.defines.USE_DASH="":delete this.defines.USE_DASH}get dashScale(){return this.uniforms.dashScale.value}set dashScale(t){this.uniforms.dashScale.value=t}get dashSize(){return this.uniforms.dashSize.value}set dashSize(t){this.uniforms.dashSize.value=t}get dashOffset(){return this.uniforms.dashOffset.value}set dashOffset(t){this.uniforms.dashOffset.value=t}get gapSize(){return this.uniforms.gapSize.value}set gapSize(t){this.uniforms.gapSize.value=t}get opacity(){return this.uniforms.opacity.value}set opacity(t){this.uniforms&&(this.uniforms.opacity.value=t)}get resolution(){return this.uniforms.resolution.value}set resolution(t){this.uniforms.resolution.value.copy(t)}get alphaToCoverage(){return"USE_ALPHA_TO_COVERAGE"in this.defines}set alphaToCoverage(t){this.defines&&(!0===t!==this.alphaToCoverage&&(this.needsUpdate=!0),!0===t?(this.defines.USE_ALPHA_TO_COVERAGE="",this.extensions.derivatives=!0):(delete this.defines.USE_ALPHA_TO_COVERAGE,this.extensions.derivatives=!1))}}const b=new e.Box3,y=new e.Vector3;class w extends e.InstancedBufferGeometry{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.setAttribute("position",new e.Float32BufferAttribute([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.setAttribute("uv",new e.Float32BufferAttribute([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))}applyMatrix4(t){const e=this.attributes.instanceStart,n=this.attributes.instanceEnd;return void 0!==e&&(e.applyMatrix4(t),n.applyMatrix4(t),e.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}setPositions(t){let n;t instanceof Float32Array?n=t:Array.isArray(t)&&(n=new Float32Array(t));const i=new e.InstancedInterleavedBuffer(n,6,1);return this.setAttribute("instanceStart",new e.InterleavedBufferAttribute(i,3,0)),this.setAttribute("instanceEnd",new e.InterleavedBufferAttribute(i,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(t){let n;t instanceof Float32Array?n=t:Array.isArray(t)&&(n=new Float32Array(t));const i=new e.InstancedInterleavedBuffer(n,6,1);return this.setAttribute("instanceColorStart",new e.InterleavedBufferAttribute(i,3,0)),this.setAttribute("instanceColorEnd",new e.InterleavedBufferAttribute(i,3,3)),this}fromWireframeGeometry(t){return this.setPositions(t.attributes.position.array),this}fromEdgesGeometry(t){return this.setPositions(t.attributes.position.array),this}fromMesh(t){return this.fromWireframeGeometry(new e.WireframeGeometry(t.geometry)),this}fromLineSegments(t){const e=t.geometry;return this.setPositions(e.attributes.position.array),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new e.Box3);const t=this.attributes.instanceStart,n=this.attributes.instanceEnd;void 0!==t&&void 0!==n&&(this.boundingBox.setFromBufferAttribute(t),b.setFromBufferAttribute(n),this.boundingBox.union(b))}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new e.Sphere),null===this.boundingBox&&this.computeBoundingBox();const t=this.attributes.instanceStart,n=this.attributes.instanceEnd;if(void 0!==t&&void 0!==n){const e=this.boundingSphere.center;this.boundingBox.getCenter(e);let i=0;for(let s=0,o=t.count;s<o;s++)y.fromBufferAttribute(t,s),i=Math.max(i,e.distanceToSquared(y)),y.fromBufferAttribute(n,s),i=Math.max(i,e.distanceToSquared(y));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(t){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(t)}}const x=new e.Vector3,S=new e.Vector3,E=new e.Vector4,L=new e.Vector4,C=new e.Vector4,M=new e.Vector3,A=new e.Matrix4,O=new e.Line3,T=new e.Vector3,_=new e.Box3,z=new e.Sphere,P=new e.Vector4;let j,I;function V(t,e,n){return P.set(0,0,-e,1).applyMatrix4(t.projectionMatrix),P.multiplyScalar(1/P.w),P.x=I/n.width,P.y=I/n.height,P.applyMatrix4(t.projectionMatrixInverse),P.multiplyScalar(1/P.w),Math.abs(Math.max(P.x,P.y))}class D extends e.Mesh{constructor(t=new w,e=new v({color:16777215*Math.random()})){super(t,e),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const t=this.geometry,n=t.attributes.instanceStart,i=t.attributes.instanceEnd,s=new Float32Array(2*n.count);for(let t=0,e=0,o=n.count;t<o;t++,e+=2)x.fromBufferAttribute(n,t),S.fromBufferAttribute(i,t),s[e]=0===e?0:s[e-1],s[e+1]=s[e]+x.distanceTo(S);const o=new e.InstancedInterleavedBuffer(s,2,1);return t.setAttribute("instanceDistanceStart",new e.InterleavedBufferAttribute(o,1,0)),t.setAttribute("instanceDistanceEnd",new e.InterleavedBufferAttribute(o,1,1)),this}raycast(t,n){const i=this.material.worldUnits,s=t.camera;null!==s||i||console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const o=void 0!==t.params.Line2&&t.params.Line2.threshold||0;j=t.ray;const r=this.matrixWorld,a=this.geometry,l=this.material;let d,c;if(I=l.linewidth+o,null===a.boundingSphere&&a.computeBoundingSphere(),z.copy(a.boundingSphere).applyMatrix4(r),i)d=.5*I;else{d=V(s,Math.max(s.near,z.distanceToPoint(j.origin)),l.resolution)}if(z.radius+=d,!1!==j.intersectsSphere(z)){if(null===a.boundingBox&&a.computeBoundingBox(),_.copy(a.boundingBox).applyMatrix4(r),i)c=.5*I;else{c=V(s,Math.max(s.near,_.distanceToPoint(j.origin)),l.resolution)}_.expandByScalar(c),!1!==j.intersectsBox(_)&&(i?function(t,n){const i=t.matrixWorld,s=t.geometry,o=s.attributes.instanceStart,r=s.attributes.instanceEnd;for(let a=0,l=Math.min(s.instanceCount,o.count);a<l;a++){O.start.fromBufferAttribute(o,a),O.end.fromBufferAttribute(r,a),O.applyMatrix4(i);const s=new e.Vector3,l=new e.Vector3;j.distanceSqToSegment(O.start,O.end,l,s),l.distanceTo(s)<.5*I&&n.push({point:l,pointOnLine:s,distance:j.origin.distanceTo(l),object:t,face:null,faceIndex:a,uv:null,uv1:null})}}(this,n):function(t,n,i){const s=n.projectionMatrix,o=t.material.resolution,r=t.matrixWorld,a=t.geometry,l=a.attributes.instanceStart,d=a.attributes.instanceEnd,c=Math.min(a.instanceCount,l.count),h=-n.near;j.at(1,C),C.w=1,C.applyMatrix4(n.matrixWorldInverse),C.applyMatrix4(s),C.multiplyScalar(1/C.w),C.x*=o.x/2,C.y*=o.y/2,C.z=0,M.copy(C),A.multiplyMatrices(n.matrixWorldInverse,r);for(let n=0,a=c;n<a;n++){if(E.fromBufferAttribute(l,n),L.fromBufferAttribute(d,n),E.w=1,L.w=1,E.applyMatrix4(A),L.applyMatrix4(A),E.z>h&&L.z>h)continue;if(E.z>h){const t=E.z-L.z,e=(E.z-h)/t;E.lerp(L,e)}else if(L.z>h){const t=L.z-E.z,e=(L.z-h)/t;L.lerp(E,e)}E.applyMatrix4(s),L.applyMatrix4(s),E.multiplyScalar(1/E.w),L.multiplyScalar(1/L.w),E.x*=o.x/2,E.y*=o.y/2,L.x*=o.x/2,L.y*=o.y/2,O.start.copy(E),O.start.z=0,O.end.copy(L),O.end.z=0;const a=O.closestPointToPointParameter(M,!0);O.at(a,T);const c=e.MathUtils.lerp(E.z,L.z,a),u=c>=-1&&c<=1,p=M.distanceTo(T)<.5*I;if(u&&p){O.start.fromBufferAttribute(l,n),O.end.fromBufferAttribute(d,n),O.start.applyMatrix4(r),O.end.applyMatrix4(r);const s=new e.Vector3,o=new e.Vector3;j.distanceSqToSegment(O.start,O.end,o,s),i.push({point:o,pointOnLine:s,distance:j.origin.distanceTo(o),object:t,face:null,faceIndex:n,uv:null,uv1:null})}}}(this,s,n))}}}class F extends e.LineSegments{constructor(t,n,i,s,o=4473924,r=8947848){o=new e.Color(o),r=new e.Color(r);const a=Math.round(t/n);i=Math.round(i/s)*s/2;const l=[],d=[];let c=0;for(let e=-1*(t=a*n/2);e<=t;e+=n){l.push(e,0,-1*i,e,0,i);const t=0===e?o:r;t.toArray(d,c),c+=3,t.toArray(d,c),c+=3,t.toArray(d,c),c+=3,t.toArray(d,c),c+=3}for(let e=-1*i;e<=i;e+=s){l.push(-1*t,0,e,t,0,e);const n=0===e?o:r;n.toArray(d,c),c+=3,n.toArray(d,c),c+=3,n.toArray(d,c),c+=3,n.toArray(d,c),c+=3}const h=new e.BufferGeometry;h.setAttribute("position",new e.Float32BufferAttribute(l,3)),h.setAttribute("color",new e.Float32BufferAttribute(d,3));super(h,new e.LineBasicMaterial({vertexColors:!0,toneMapped:!1}))}}function U(t,n,i,s){const o=function(t,n,i){t*=.5,n*=.5,i*=.5;const s=new e.BufferGeometry,o=[];return o.push(-t,-n,-i,-t,n,-i,-t,n,-i,t,n,-i,t,n,-i,t,-n,-i,t,-n,-i,-t,-n,-i,-t,-n,i,-t,n,i,-t,n,i,t,n,i,t,n,i,t,-n,i,t,-n,i,-t,-n,i,-t,-n,-i,-t,-n,i,-t,n,-i,-t,n,i,t,n,-i,t,n,i,t,-n,-i,t,-n,i),s.setAttribute("position",new e.Float32BufferAttribute(o,3)),s}(t,n,i),r=new e.LineSegments(o,new e.LineDashedMaterial({color:new e.Color(s),dashSize:3,gapSize:1}));return r.computeLineDistances(),r}var R=function(){var t=0,e=document.createElement("div");function n(t){return e.appendChild(t.dom),t}function i(n){for(var i=0;i<e.children.length;i++)e.children[i].style.display=i===n?"block":"none";t=n}e.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",e.addEventListener("click",(function(n){n.preventDefault(),i(++t%e.children.length)}),!1);var s=(performance||Date).now(),o=s,r=0,a=n(new R.Panel("FPS","#0ff","#002")),l=n(new R.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var d=n(new R.Panel("MB","#f08","#201"));return i(0),{REVISION:16,dom:e,addPanel:n,showPanel:i,begin:function(){s=(performance||Date).now()},end:function(){r++;var t=(performance||Date).now();if(l.update(t-s,200),t>=o+1e3&&(a.update(1e3*r/(t-o),100),o=t,r=0,d)){var e=performance.memory;d.update(e.usedJSHeapSize/1048576,e.jsHeapSizeLimit/1048576)}return t},update:function(){s=this.end()},domElement:e,setMode:i}};R.Panel=function(t,e,n){var i=1/0,s=0,o=Math.round,r=o(window.devicePixelRatio||1),a=80*r,l=48*r,d=3*r,c=2*r,h=3*r,u=15*r,p=74*r,m=30*r,f=document.createElement("canvas");f.width=a,f.height=l,f.style.cssText="width:80px;height:48px";var g=f.getContext("2d");return g.font="bold "+9*r+"px Helvetica,Arial,sans-serif",g.textBaseline="top",g.fillStyle=n,g.fillRect(0,0,a,l),g.fillStyle=e,g.fillText(t,d,c),g.fillRect(h,u,p,m),g.fillStyle=n,g.globalAlpha=.9,g.fillRect(h,u,p,m),{dom:f,update:function(l,v){i=Math.min(i,l),s=Math.max(s,l),g.fillStyle=n,g.globalAlpha=1,g.fillRect(0,0,a,u),g.fillStyle=e,g.fillText(o(l)+" "+t+" ("+o(i)+"-"+o(s)+")",d,c),g.drawImage(f,h+r,u,p-r,m,h,u,p-r,m),g.fillRect(h+p-r,u,r,m),g.fillStyle=n,g.globalAlpha=.9,g.fillRect(h+p-r,u,r,o((1-l/v)*m))}}};var B=R;class H{constructor(t,e){this.openFolders=[],this.watchedObject=t,this.options=e,this.gui=new n.GUI,this.gui.title("Dev info"),this.setup()}setup(){this.loadOpenFolders(),this.options&&!this.options.renderer||this.setupRedererFolder(),this.options&&!this.options.camera||this.setupCameraFolder(),this.options&&!this.options.parser||this.setupParserFolder(),this.options&&!this.options.buildVolume||this.setupBuildVolumeFolder(),this.options&&!this.options.devHelpers||this.setupDevHelpers()}reset(){this.gui.destroy(),this.gui=new n.GUI,this.gui.title("Dev info"),this.setup()}loadOpenFolders(){this.openFolders=JSON.parse(localStorage.getItem("dev-gui-open")||"{}").open||[]}saveOpenFolders(){this.openFolders=this.gui.foldersRecursive().filter((t=>!t._closed)).map((t=>t._title)),console.log(this.openFolders),localStorage.setItem("dev-gui-open",JSON.stringify({open:this.openFolders}))}setupRedererFolder(){const t=this.gui.addFolder("Render Info");this.openFolders.includes("Render Info")||t.close(),t.onOpenClose((()=>{this.saveOpenFolders()})),t.add(this.watchedObject.renderer.info.render,"triangles").listen(),t.add(this.watchedObject.renderer.info.render,"calls").listen(),t.add(this.watchedObject.renderer.info.render,"lines").listen(),t.add(this.watchedObject.renderer.info.render,"points").listen(),t.add(this.watchedObject.renderer.info.memory,"geometries").listen(),t.add(this.watchedObject.renderer.info.memory,"textures").listen(),t.add(this.watchedObject,"_lastRenderTime").listen()}setupCameraFolder(){const t=this.gui.addFolder("Camera");this.openFolders.includes("Camera")||t.close(),t.onOpenClose((()=>{this.saveOpenFolders()}));const e=t.addFolder("Camera position");e.add(this.watchedObject.camera.position,"x").listen(),e.add(this.watchedObject.camera.position,"y").listen(),e.add(this.watchedObject.camera.position,"z").listen();const n=t.addFolder("Camera rotation");n.add(this.watchedObject.camera.rotation,"x").listen(),n.add(this.watchedObject.camera.rotation,"y").listen(),n.add(this.watchedObject.camera.rotation,"z").listen()}setupParserFolder(){const t=this.gui.addFolder("Parser");this.openFolders.includes("Parser")||t.close(),t.onOpenClose((()=>{this.saveOpenFolders()})),t.add(this.watchedObject.parser,"curZ").listen(),t.add(this.watchedObject.parser,"maxZ").listen(),t.add(this.watchedObject.parser,"tolerance").listen(),t.add(this.watchedObject.parser.layers,"length").name("layers.count").listen(),t.add(this.watchedObject.parser.lines,"length").name("lines.count").listen()}setupBuildVolumeFolder(){const t=this.gui.addFolder("Build Volume");this.openFolders.includes("Build Volume")||t.close(),t.onOpenClose((()=>{this.saveOpenFolders()})),t.add(this.watchedObject.buildVolume,"x").min(0).max(600).listen().onChange((()=>{this.watchedObject.render()})),t.add(this.watchedObject.buildVolume,"y").min(0).max(600).listen().onChange((()=>{this.watchedObject.render()})),t.add(this.watchedObject.buildVolume,"z").min(0).max(600).listen().onChange((()=>{this.watchedObject.render()}))}setupDevHelpers(){const t=this.gui.addFolder("Dev Helpers");this.openFolders.includes("Dev Helpers")||t.close(),t.onOpenClose((()=>{this.saveOpenFolders()})),t.add(this.watchedObject,"_wireframe").listen().onChange((()=>{this.watchedObject.render()})),t.add(this.watchedObject,"render").listen(),t.add(this.watchedObject,"clear").listen()}}class N extends e.BufferGeometry{constructor(t=[new e.Vector3],n=.6,i=.2,s=8){super(),this.type="ExtrusionGeometry",this.parameters={points:t,lineWidth:n,lineHeight:i,radialSegments:s,closed:!1};const o=new e.Vector3,r=new e.Vector3,a=new e.Vector2,l=[],d=[],c=[],h=[];function u(a){const[c,h,u]=function(n){const i=t[n],s=new e.Vector3,o=new e.Vector3,r=new e.Vector3,a=new e.Vector3;s.copy(i).sub(t[n-1]||i).normalize().add((t[n+1]||i).clone().sub(i).normalize()).normalize();let l=Number.MAX_VALUE;const d=Math.abs(s.x),c=Math.abs(s.y),h=Math.abs(s.z);d<=l&&(l=d,o.set(1,0,0));c<=l&&(l=c,o.set(0,1,0));h<=l&&o.set(0,0,1);return a.crossVectors(s,o).normalize(),o.crossVectors(s,a),r.crossVectors(s,o),[i,o,r]}(a);for(let t=0;t<=s;t++){const e=t/s*Math.PI*2,a=Math.sin(e),p=-Math.cos(e);r.x=p*h.x+a*u.x,r.y=p*h.y+a*u.y,r.z=p*h.z+a*u.z,r.normalize(),d.push(r.x,r.y,r.z),o.x=c.x+n*r.x*.5,o.y=c.y+n*r.y*.5,o.z=c.z+i*r.z*.5,l.push(o.x,o.y,o.z)}}!function(){for(let e=0;e<t.length;e++)u(e);u(!1===closed?t.length-1:0),function(){for(let e=0;e<t.length;e++)for(let n=0;n<=s;n++)a.x=e/t.length,a.y=n/s,c.push(a.x,a.y)}(),function(){for(let e=1;e<t.length;e++)for(let t=1;t<=s;t++){const n=(s+1)*(e-1)+(t-1),i=(s+1)*e+(t-1),o=(s+1)*e+t,r=(s+1)*(e-1)+t;h.push(n,i,r),h.push(i,o,r)}}()}(),this.setIndex(h),this.setAttribute("position",new e.Float32BufferAttribute(l,3)),this.setAttribute("normal",new e.Float32BufferAttribute(d,3)),this.setAttribute("uv",new e.Float32BufferAttribute(c,2))}}class k{static get initial(){const t=new k;return Object.assign(t,{x:0,y:0,z:0,r:0,e:0,i:0,j:0,t:0}),t}}const G={h:0,s:0,l:0};class W{constructor(t){var n,i,s,o,r,a,l,c,h;if(this.minLayerThreshold=.05,this.renderExtrusion=!0,this.renderTravel=!1,this.renderTubes=!1,this.extrusionWidth=.6,this.singleLayerMode=!1,this.initialCameraPosition=[-100,400,450],this.debug=!1,this.inches=!1,this.nonTravelmoves=[],this.disableGradient=!1,this.state=k.initial,this.beyondFirstMove=!1,this.disposables=[],this._extrusionColor=W.defaultExtrusionColor,this.renderLayerIndex=0,this._geometries={},this._backgroundColor=new e.Color(14737632),this._travelColor=new e.Color(10027008),this._toolColors={},this.devMode=!1,this._lastRenderTime=0,this._wireframe=!1,this.minLayerThreshold=null!==(n=t.minLayerThreshold)&&void 0!==n?n:this.minLayerThreshold,this.parser=new d(this.minLayerThreshold),this.scene=new e.Scene,this.scene.background=this._backgroundColor,void 0!==t.backgroundColor&&(this.backgroundColor=new e.Color(t.backgroundColor)),this.targetId=t.targetId,this.endLayer=t.endLayer,this.startLayer=t.startLayer,this.lineWidth=t.lineWidth,this.lineHeight=t.lineHeight,this.buildVolume=t.buildVolume,this.initialCameraPosition=null!==(i=t.initialCameraPosition)&&void 0!==i?i:this.initialCameraPosition,this.debug=null!==(s=t.debug)&&void 0!==s?s:this.debug,this.renderExtrusion=null!==(o=t.renderExtrusion)&&void 0!==o?o:this.renderExtrusion,this.renderTravel=null!==(r=t.renderTravel)&&void 0!==r?r:this.renderTravel,this.nonTravelmoves=null!==(a=t.nonTravelMoves)&&void 0!==a?a:this.nonTravelmoves,this.renderTubes=null!==(l=t.renderTubes)&&void 0!==l?l:this.renderTubes,this.extrusionWidth=null!==(c=t.extrusionWidth)&&void 0!==c?c:this.extrusionWidth,this.devMode=null!==(h=t.devMode)&&void 0!==h?h:this.devMode,this.stats=this.devMode?new B:void 0,void 0!==t.extrusionColor&&(this.extrusionColor=t.extrusionColor),void 0!==t.travelColor&&(this.travelColor=new e.Color(t.travelColor)),void 0!==t.topLayerColor&&(this.topLayerColor=new e.Color(t.topLayerColor)),void 0!==t.lastSegmentColor&&(this.lastSegmentColor=new e.Color(t.lastSegmentColor)),t.toolColors){this._toolColors={};for(const[n,i]of Object.entries(t.toolColors))this._toolColors[parseInt(n)]=new e.Color(i)}if(void 0!==t.disableGradient&&(this.disableGradient=t.disableGradient),console.info("Using THREE r"+e.REVISION),console.debug("opts",t),this.targetId&&console.warn("`targetId` is deprecated and will removed in the future. Use `canvas` instead."),t.canvas)this.canvas=t.canvas,this.renderer=new e.WebGLRenderer({canvas:this.canvas,preserveDrawingBuffer:!0});else{if(!this.targetId)throw Error("Set either opts.canvas or opts.targetId");const t=document.getElementById(this.targetId);if(!t)throw new Error("Unable to find element "+this.targetId);this.renderer=new e.WebGLRenderer({preserveDrawingBuffer:!0}),this.canvas=this.renderer.domElement,t.appendChild(this.canvas)}this.camera=new e.PerspectiveCamera(25,this.canvas.offsetWidth/this.canvas.offsetHeight,10,5e3),this.camera.position.fromArray(this.initialCameraPosition);const u=this.camera.far,p=.8*u;this.scene.fog=new e.Fog(this._backgroundColor,p,u),this.resize(),this.controls=new g(this.camera,this.renderer.domElement),this.initScene(),this.animate(),t.allowDragNDrop&&this._enableDropHandler(),this.initStats()}get extrusionColor(){return this._extrusionColor}set extrusionColor(t){if(Array.isArray(t)){this._extrusionColor=[];for(const[n,i]of t.entries())this._extrusionColor[n]=new e.Color(i)}else this._extrusionColor=new e.Color(t)}get currentToolColor(){var t;return void 0===this._extrusionColor?W.defaultExtrusionColor:this._extrusionColor instanceof e.Color?this._extrusionColor:null!==(t=this._extrusionColor[this.state.t])&&void 0!==t?t:W.defaultExtrusionColor}get backgroundColor(){return this._backgroundColor}set backgroundColor(t){this._backgroundColor=new e.Color(t),this.scene.background=this._backgroundColor}get travelColor(){return this._travelColor}set travelColor(t){this._travelColor=new e.Color(t)}get topLayerColor(){return this._topLayerColor}set topLayerColor(t){this._topLayerColor=void 0!==t?new e.Color(t):void 0}get lastSegmentColor(){return this._lastSegmentColor}set lastSegmentColor(t){this._lastSegmentColor=void 0!==t?new e.Color(t):void 0}get layers(){return[this.parser.preamble].concat(this.parser.layers.concat())}get maxLayerIndex(){var t;return(null!==(t=this.endLayer)&&void 0!==t?t:this.layers.length)-1}get minLayerIndex(){var t;return this.singleLayerMode?this.maxLayerIndex:(null!==(t=this.startLayer)&&void 0!==t?t:0)-1}animate(){var t;this.animationFrameId=requestAnimationFrame((()=>this.animate())),this.controls.update(),this.renderer.render(this.scene,this.camera),null===(t=this.stats)||void 0===t||t.update()}processGCode(t){this.parser.parseGCode(t),this.render()}initScene(){for(;this.scene.children.length>0;)this.scene.remove(this.scene.children[0]);for(;this.disposables.length>0;){const t=this.disposables.pop();t&&t.dispose()}if(this.debug&&this.buildVolume){const t=new e.AxesHelper(Math.max(this.buildVolume.x/2,this.buildVolume.y/2)+20);this.scene.add(t)}if(this.buildVolume&&this.drawBuildVolume(),this.renderTubes){console.warn("Volumetric rendering is experimental. It may not work as expected or change in the future.");const t=new e.AmbientLight(13421772,.3*Math.PI),n=new e.PointLight(16777215,Math.PI,void 0,.001);n.position.set(0,500,500),this.scene.add(t),this.scene.add(n)}}createGroup(t){const n=new e.Group;return n.name=t,n.quaternion.setFromEuler(new e.Euler(-Math.PI/2,0,0)),this.buildVolume?n.position.set(-this.buildVolume.x/2,0,this.buildVolume.y/2):n.position.set(-100,0,100),n}render(){const t=performance.now();this.group=this.createGroup("allLayers"),this.state=k.initial,this.initScene();for(let t=0;t<this.layers.length;t++)this.renderLayer(t);this.batchGeometries(),this.scene.add(this.group),this.renderer.render(this.scene,this.camera),this._lastRenderTime=performance.now()-t}renderAnimated(t=1){return i(this,void 0,void 0,(function*(){return this.initScene(),this.renderLayerIndex=0,this.renderFrameLoop(t>0?t:1)}))}renderFrameLoop(t){return new Promise((e=>{const n=()=>{this.renderLayerIndex>this.layers.length-1?e():(this.renderFrame(t),requestAnimationFrame(n))};n()}))}renderFrame(t){this.group=this.createGroup("layer"+this.renderLayerIndex);for(let e=0;e<t&&this.renderLayerIndex+e<this.layers.length;e++)this.renderLayer(this.renderLayerIndex),this.renderLayerIndex++;this.batchGeometries(),this.scene.add(this.group)}renderLayer(t){var e,n,i,s,o,r,a,l;if(t>this.maxLayerIndex)return;const d=this.layers[t],c={extrusion:[],travel:[],z:this.state.z,height:d.height};for(const h of d.commands)if("g20"!=h.gcode){if(h.gcode.startsWith("t")){this.doRenderExtrusion(c,t),c.extrusion=[];const e=h;this.state.t=e.toolIndex}else if(["g0","g00","g1","g01","g2","g02","g3","g03"].indexOf(h.gcode)>-1){const d=h,u={x:null!==(e=d.params.x)&&void 0!==e?e:this.state.x,y:null!==(n=d.params.y)&&void 0!==n?n:this.state.y,z:null!==(i=d.params.z)&&void 0!==i?i:this.state.z,r:null!==(s=d.params.r)&&void 0!==s?s:this.state.r,e:null!==(o=d.params.e)&&void 0!==o?o:this.state.e,i:null!==(r=d.params.i)&&void 0!==r?r:this.state.i,j:null!==(a=d.params.j)&&void 0!==a?a:this.state.j,t:this.state.t};if(t>=this.minLayerIndex){const t=(null!==(l=d.params.e)&&void 0!==l?l:0)>0||this.nonTravelmoves.indexOf(h.gcode)>-1;(u.x!=this.state.x||u.y!=this.state.y||u.z!=this.state.z)&&(t&&this.renderExtrusion||!t&&this.renderTravel)&&("g2"==h.gcode||"g3"==h.gcode||"g02"==h.gcode||"g03"==h.gcode?this.addArcSegment(c,this.state,u,t,"g2"==h.gcode||"g02"==h.gcode):this.addLineSegment(c,this.state,u,t))}this.state.x=u.x,this.state.y=u.y,this.state.z=u.z,this.beyondFirstMove||(this.beyondFirstMove=!0)}}else this.setInches();this.doRenderExtrusion(c,t)}doRenderExtrusion(t,n){var i,s;if(this.renderExtrusion){let o=this.currentToolColor;if(!this.singleLayerMode&&!this.renderTubes&&!this.disableGradient){const t=.1+.7*n/this.layers.length;o.getHSL(G),o=(new e.Color).setHSL(G.h,G.s,t)}if(n==this.layers.length-1){const e=null!==(i=this._topLayerColor)&&void 0!==i?i:o,n=null!==(s=this._lastSegmentColor)&&void 0!==s?s:e,r=t.extrusion.splice(-3),a=t.extrusion.splice(-3);this.renderTubes?(this.addTubeLine(t.extrusion,e.getHex(),t.height),this.addTubeLine([...a,...r],n.getHex(),t.height)):(this.addLine(t.extrusion,e.getHex()),this.addLine([...a,...r],n.getHex()))}else this.renderTubes?this.addTubeLine(t.extrusion,o.getHex(),t.height):this.addLine(t.extrusion,o.getHex())}this.renderTravel&&this.addLine(t.travel,this._travelColor.getHex())}setInches(){this.beyondFirstMove?console.warn("Switching units after movement is already made is discouraged and is not supported."):this.inches=!0}drawBuildVolume(){if(!this.buildVolume)return;this.scene.add(new F(this.buildVolume.x,10,this.buildVolume.y,10));const t=U(this.buildVolume.x,this.buildVolume.z,this.buildVolume.y,8947848);t.position.setY(this.buildVolume.z/2),this.scene.add(t)}clear(){this.resetState(),this.parser=new d(this.minLayerThreshold)}resetState(){var t;this.startLayer=1,this.endLayer=1/0,this.singleLayerMode=!1,this.beyondFirstMove=!1,this.state=k.initial,null===(t=this.devGui)||void 0===t||t.reset(),this._geometries={}}resize(){const[t,e]=[this.canvas.offsetWidth,this.canvas.offsetHeight];this.camera.aspect=t/e,this.camera.updateProjectionMatrix(),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(t,e,!1)}addLineSegment(t,e,n,i){(i?t.extrusion:t.travel).push(e.x,e.y,e.z,n.x,n.y,n.z)}addArcSegment(t,e,n,i,s){const o=i?t.extrusion:t.travel,r=e.x,a=e.y,l=e.z,d=n.x,c=n.y,h=n.z;let u=n.r,p=n.i,m=n.j;if(u){const t=d-r,e=c-a,n=Math.sqrt(Math.pow(t/2,2)+Math.pow(e/2,2));u=Math.max(u,n);const i=Math.pow(t,2)+Math.pow(e,2),o=Math.pow(u,2)-i/4;let l=Math.sqrt(o/i);(s&&u<0||!s&&u>0)&&(l=-l),p=t/2+e*l,m=e/2-t*l}const f=r==d&&a==c,g=r+p,v=a+m,b=Math.sqrt(p*p+m*m),y=Math.atan2(-m,-p),w=Math.atan2(c-v,d-g);let x;f?x=2*Math.PI:(x=s?y-w:w-y,x<0&&(x+=2*Math.PI));let S=b*x/1.8;this.inches&&(S*=25),S<1&&(S=1);let E=x/S;E*=s?-1:1;const L=[];L.push({x:r,y:a,z:l});const C=(l-h)/S;let M=r,A=a,O=l,T=y;for(let t=0;t<S-1;t++)T+=E,M=g+b*Math.cos(T),A=v+b*Math.sin(T),O+=C,L.push({x:M,y:A,z:O});L.push({x:n.x,y:n.y,z:n.z});for(let t=0;t<L.length-1;t++)o.push(L[t].x,L[t].y,L[t].z,L[t+1].x,L[t+1].y,L[t+1].z)}addLine(t,n){var i;if("number"==typeof this.lineWidth&&this.lineWidth>0)return void this.addThickLine(t,n);const s=new e.BufferGeometry;s.setAttribute("position",new e.Float32BufferAttribute(t,3)),this.disposables.push(s);const o=new e.LineBasicMaterial({color:n});this.disposables.push(o);const r=new e.LineSegments(s,o);null===(i=this.group)||void 0===i||i.add(r)}addTubeLine(t,n,i=.2){let s=[];const o=[];for(let n=0;n<t.length;n+=6){const i=t.slice(n,n+9),r=new e.Vector3(i[0],i[1],i[2]),a=new e.Vector3(i[3],i[4],i[5]),l=new e.Vector3(i[6],i[7],i[8]);s.push(r),a.equals(l)||(s.push(a),o.push(s),s=[])}o.forEach((t=>{var e;const s=new N(t,this.extrusionWidth,this.lineHeight||i,4);(e=this._geometries)[n]||(e[n]=[]),this._geometries[n].push(s)}))}addThickLine(t,e){var n;if(!t.length||!this.lineWidth)return;const i=new w;this.disposables.push(i);const s=new v({color:e,linewidth:this.lineWidth/(1e3*window.devicePixelRatio)});this.disposables.push(s),i.setPositions(t);const o=new D(i,s);null===(n=this.group)||void 0===n||n.add(o)}dispose(){this.disposables.forEach((t=>t.dispose())),this.disposables=[],this.controls.dispose(),this.renderer.dispose(),this.cancelAnimation()}cancelAnimation(){void 0!==this.animationFrameId&&cancelAnimationFrame(this.animationFrameId),this.animationFrameId=void 0}_enableDropHandler(){console.warn("Drag and drop is deprecated as a library feature. See the demo how to implement your own."),this.canvas.addEventListener("dragover",(t=>{t.stopPropagation(),t.preventDefault(),t.dataTransfer&&(t.dataTransfer.dropEffect="copy"),this.canvas.classList.add("dragging")})),this.canvas.addEventListener("dragleave",(t=>{t.stopPropagation(),t.preventDefault(),this.canvas.classList.remove("dragging")})),this.canvas.addEventListener("drop",(t=>i(this,void 0,void 0,(function*(){var e,n;t.stopPropagation(),t.preventDefault(),this.canvas.classList.remove("dragging");const i=(null!==(n=null===(e=t.dataTransfer)||void 0===e?void 0:e.files)&&void 0!==n?n:[])[0];this.clear(),yield this._readFromStream(i.stream()),this.render()}))))}batchGeometries(){if(this._geometries)for(const t in this._geometries){const e=this.createBatchMesh(parseInt(t));for(;this._geometries[t].length>0;){const n=this._geometries[t].pop();e.addGeometry(n)}}}createBatchMesh(t){var n;const i=this._geometries[t],s=new e.MeshLambertMaterial({color:t,wireframe:this._wireframe});this.disposables.push(s);const o=i.reduce(((t,e)=>3*e.attributes.position.count+t),0),r=new e.BatchedMesh(i.length,o,void 0,s);return this.disposables.push(r),null===(n=this.group)||void 0===n||n.add(r),r}_readFromStream(t){var e,n;return i(this,void 0,void 0,(function*(){const i=t.getReader();let s,o="",r=0;do{console.debug("reading from stream"),s=yield i.read(),r+=null!==(n=null===(e=s.value)||void 0===e?void 0:e.length)&&void 0!==n?n:0;const t=(a=s.value,new TextDecoder("utf-8").decode(a)),l=t.lastIndexOf("\n"),d=t.slice(0,l);this.parser.parseGCode(o+d),o=t.slice(l)}while(!s.done);var a;console.debug("read from stream",r)}))}initGui(){"boolean"==typeof this.devMode&&!0===this.devMode?this.devGui=new H(this):"object"==typeof this.devMode&&(this.devGui=new H(this,this.devMode))}initStats(){var t;this.stats&&("object"==typeof this.devMode&&(this.statsContainer=this.devMode.statsContainer),(null!==(t=this.statsContainer)&&void 0!==t?t:document.body).appendChild(this.stats.dom),this.stats.dom.classList.add("stats"),this.initGui())}}W.defaultExtrusionColor=new e.Color("hotpink");t.WebGLPreview=W,t.init=function(t){return new W(t)},Object.defineProperty(t,"__esModule",{value:!0})}));
